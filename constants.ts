import type { QuestionCategory, QuestionDifficulty, Question } from './types';

export const INTERVIEW_QUESTION_COUNT = 10;

const rawQuestions: Omit<Question, 'id' | 'status' | 'category'>[] = [
    // Java Căn Bản
    { question: "Java là gì?", answer: "Java là một ngôn ngữ lập trình hướng đối tượng, độc lập nền tảng, được thiết kế để có cú pháp đơn giản, mạnh mẽ và bảo mật.", difficulty: 'Dễ' },
    { question: "JVM là gì? JRE là gì? JDK là gì?", answer: "<ul><li><strong>JVM (Java Virtual Machine):</strong> Là một máy ảo chạy các chương trình Java, chuyển đổi bytecode thành mã máy.</li><li><strong>JRE (Java Runtime Environment):</strong> Bao gồm JVM và các thư viện, lớp cần thiết để chạy các ứng dụng Java.</li><li><strong>JDK (Java Development Kit):</strong> Bao gồm JRE và các công cụ phát triển như trình biên dịch (javac), trình gỡ lỗi.</li></ul>", difficulty: 'Dễ' },
    { question: "Sự khác nhau giữa JDK và JRE?", answer: "JDK bao gồm JRE và các công cụ phát triển (compiler, debugger). JRE chỉ chứa JVM và thư viện để *chạy* ứng dụng.", difficulty: 'Dễ' },
    { question: "Nêu các tính năng chính của Java.", answer: "Hướng đối tượng, độc lập nền tảng, mạnh mẽ, bảo mật, đa luồng, kiến trúc trung lập, thông dịch, hiệu suất cao, phân tán, dễ học.", difficulty: 'Trung bình' },
    { question: "Giải thích khái niệm 'Platform Independence' trong Java.", answer: "Chương trình Java được biên dịch thành bytecode. Bytecode này có thể chạy trên bất kỳ nền tảng nào có JVM mà không cần thay đổi mã nguồn (Write Once, Run Anywhere).", difficulty: 'Trung bình' },
    { question: "Sự khác nhau giữa Java và C++?", answer: "Java đơn giản hơn, không hỗ trợ con trỏ trực tiếp, có quản lý bộ nhớ tự động (Garbage Collection), hỗ trợ đa luồng tốt hơn, và hoàn toàn hướng đối tượng.", difficulty: 'Trung bình' },
    { question: "Định nghĩa biến trong Java. Có những loại biến nào?", answer: "Biến là một vị trí trong bộ nhớ dùng để lưu trữ dữ liệu. Các loại biến gồm: <ul><li>Biến địa phương (Local variable)</li><li>Biến instance (Instance variable)</li><li>Biến class (Static variable)</li></ul>", difficulty: 'Dễ' },
    { question: "Giải thích về các kiểu dữ liệu nguyên thủy trong Java.", answer: "Java có 8 kiểu dữ liệu nguyên thủy: `byte`, `short`, `int`, `long`, `float`, `double`, `char`, và `boolean`.", difficulty: 'Dễ' },
    { question: "Sự khác nhau giữa == và equals() trong Java?", answer: "<ul><li>`==`: So sánh tham chiếu (địa chỉ bộ nhớ) nếu là đối tượng, hoặc so sánh giá trị nếu là kiểu nguyên thủy.</li><li>`equals()`: Phương thức dùng để so sánh nội dung (giá trị) của hai đối tượng.</li></ul>", difficulty: 'Trung bình' },
    { question: "String, StringBuffer, và StringBuilder khác nhau như thế nào?", answer: "<ul><li><strong>String:</strong> Bất biến (Immutable). Mỗi thay đổi tạo ra đối tượng mới.</li><li><strong>StringBuffer:</strong> Có thể thay đổi (Mutable) và đồng bộ (Synchronized) - an toàn đa luồng nhưng chậm.</li><li><strong>StringBuilder:</strong> Có thể thay đổi (Mutable) nhưng không đồng bộ - nhanh hơn StringBuffer.</li></ul>", difficulty: 'Trung bình' },
    { question: "final, finally, và finalize() khác nhau như thế nào?", answer: "<ul><li><strong>final:</strong> Từ khóa. Biến (hằng số), Phương thức (không thể override), Lớp (không thể kế thừa).</li><li><strong>finally:</strong> Khối lệnh. Luôn được thực thi sau try-catch (dù có lỗi hay không).</li><li><strong>finalize():</strong> Phương thức. Được Garbage Collector gọi trước khi đối tượng bị hủy.</li></ul>", difficulty: 'Trung bình' },
    { question: "Constructor là gì? Sự khác nhau giữa constructor và phương thức?", answer: "Constructor là một phương thức đặc biệt được gọi khi tạo đối tượng, không có kiểu trả về, tên giống tên lớp, dùng để khởi tạo giá trị ban đầu.", difficulty: 'Dễ' },
    { question: "Overloading và Overriding là gì?", answer: "<ul><li><strong>Overloading (Nạp chồng):</strong> Nhiều phương thức cùng tên trong cùng một lớp nhưng khác nhau về tham số (Compile-time).</li><li><strong>Overriding (Ghi đè):</strong> Ghi đè phương thức của lớp cha trong lớp con với cùng tên, kiểu trả về và tham số (Run-time).</li></ul>", difficulty: 'Trung bình' },
    { question: "static là gì? static được sử dụng như thế nào?", answer: "`static` là từ khóa để khai báo biến hoặc phương thức thuộc về Lớp (Class) chứ không phải đối tượng (Instance). Có thể truy cập mà không cần tạo đối tượng.", difficulty: 'Trung bình' },
    { question: "Interface là gì? Sự khác nhau giữa interface và abstract class?", answer: "<ul><li><strong>Interface:</strong> Trừu tượng hoàn toàn. Chỉ chứa method abstract (trừ default/static từ Java 8) và hằng số.</li><li><strong>Abstract class:</strong> Có thể chứa cả method trừu tượng và method có thân. Có thể có biến instance.</li></ul>", difficulty: 'Khó' },
    { question: "abstract class là gì? Khi nào sử dụng abstract class?", answer: "Là lớp không thể tạo đối tượng, chứa ít nhất một phương thức trừu tượng. Dùng khi muốn chia sẻ code (method có thân) cho các lớp con nhưng vẫn ép chúng triển khai các method trừu tượng.", difficulty: 'Trung bình' },
    { question: "super và this khác nhau như thế nào?", answer: "<ul><li>`this`: Dùng để tham chiếu đến đối tượng hiện tại (instance) của lớp.</li><li>`super`: Dùng để tham chiếu đến lớp cha (gọi constructor hoặc method của cha).</li></ul>", difficulty: 'Dễ' },
    { question: "Nêu các phạm vi truy cập (access modifiers) trong Java.", answer: "<ul><li>`private`: Chỉ truy cập trong cùng lớp.</li><li>`default` (không ghi gì): Truy cập trong cùng package.</li><li>`protected`: Truy cập trong cùng package và các lớp con.</li><li>`public`: Truy cập từ mọi nơi.</li></ul>", difficulty: 'Dễ' },
    { question: "Exception là gì? Sự khác nhau giữa checked và unchecked exception?", answer: "Exception là sự kiện bất thường. <ul><li><strong>Checked exception:</strong> Bắt buộc phải xử lý (try-catch) hoặc khai báo (throws) tại compile-time. (VD: IOException).</li><li><strong>Unchecked exception (Runtime):</strong> Không bắt buộc xử lý. (VD: NullPointerException).</li></ul>", difficulty: 'Trung bình' },
    { question: "Xử lý ngoại lệ (Exception Handling) trong Java được thực hiện như thế nào?", answer: "Sử dụng các khối `try`, `catch`, `finally`, và từ khóa `throw`, `throws`.", difficulty: 'Dễ' },
    { question: "try, catch, finally và throw, throws khác nhau như thế nào?", answer: "<ul><li>`try`: Khối mã có thể gây lỗi.</li><li>`catch`: Khối mã xử lý lỗi.</li><li>`finally`: Khối mã luôn được thực hiện.</li><li>`throw`: Ném ra một ngoại lệ.</li><li>`throws`: Khai báo ngoại lệ mà phương thức có thể ném.</li></ul>", difficulty: 'Trung bình' },
    { question: "Nêu một số lớp thông dụng trong gói java.util.", answer: "ArrayList, LinkedList, HashMap, HashSet, Date, Calendar, Random.", difficulty: 'Dễ' },
    { question: "Collections trong Java là gì? Kể tên một số loại collections.", answer: "Collections là các cấu trúc dữ liệu để lưu trữ và thao tác trên các nhóm đối tượng. Gồm: List, Set, Map, Queue.", difficulty: 'Dễ' },
    { question: "Sự khác nhau giữa ArrayList và LinkedList?", answer: "<ul><li><strong>ArrayList:</strong> Dùng mảng động. Truy cập ngẫu nhiên (get) nhanh. Chèn/xóa (đặc biệt ở giữa) chậm.</li><li><strong>LinkedList:</strong> Dùng danh sách liên kết kép. Chèn/xóa nhanh. Truy cập ngẫu nhiên chậm.</li></ul>", difficulty: 'Trung bình' },
    { question: "Sự khác nhau giữa HashMap và Hashtable?", answer: "<ul><li><strong>HashMap:</strong> Không đồng bộ, nhanh hơn, cho phép 1 key `null` và nhiều value `null`.</li><li><strong>Hashtable:</strong> Đồng bộ (thread-safe), chậm hơn, không cho phép key/value `null`.</li></ul>", difficulty: 'Trung bình' },
    
    // Lập Trình Hướng Đối Tượng (OOP)
    { question: "Lập trình hướng đối tượng (OOP) là gì?", answer: "OOP là mô hình lập trình dựa trên các đối tượng, tập trung vào việc sử dụng các đối tượng để thiết kế và triển khai các phần mềm.", difficulty: 'Dễ' },
    { question: "Nêu bốn nguyên lý cơ bản của OOP.", answer: "Encapsulation (Đóng gói), Inheritance (Kế thừa), Polymorphism (Đa hình), Abstraction (Trừu tượng).", difficulty: 'Dễ' },
    { question: "Encapsulation là gì? Tại sao nó quan trọng?", answer: "Là cơ chế ẩn dấu thông tin (dùng `private`) và chỉ cho phép truy cập qua các phương thức công khai (getter/setter). Nó giúp bảo vệ dữ liệu và kiểm soát truy cập.", difficulty: 'Trung bình' },
    { question: "Inheritance là gì? Nêu ví dụ.", answer: "Là cơ chế cho phép một lớp (con) kế thừa các thuộc tính và phương thức từ một lớp khác (cha). Ví dụ: Lớp `Dog` kế thừa từ lớp `Animal`.", difficulty: 'Dễ' },
    { question: "Polymorphism là gì? Phân biệt compile-time và run-time polymorphism.", answer: "Là khả năng của một phương thức hoặc đối tượng có nhiều hình thái khác nhau.<ul><li><strong>Compile-time (static):</strong> Thực hiện qua Overloading.</li><li><strong>Run-time (dynamic):</strong> Thực hiện qua Overriding.</li></ul>", difficulty: 'Trung bình' },
    { question: "Abstraction là gì? Làm sao để đạt được abstraction trong Java?", answer: "Là quá trình ẩn các chi tiết không cần thiết và chỉ hiển thị các chức năng cần thiết. Đạt được qua `abstract class` và `interface`.", difficulty: 'Trung bình' },
    { question: "Constructor chaining là gì?", answer: "Là quá trình một constructor gọi một constructor khác trong cùng một lớp (dùng `this()`) hoặc lớp cha (dùng `super()`).", difficulty: 'Khó' },
    { question: "instanceof operator là gì?", answer: "`instanceof` dùng để kiểm tra xem một đối tượng có phải là một instance của một lớp cụ thể hay không.", difficulty: 'Dễ' },
    { question: "Có thể ghi đè (override) method private hay static không? Tại sao?", answer: "Không. Phương thức `private` chỉ truy cập trong lớp. Phương thức `static` thuộc về lớp, không thuộc về instance, nên nó chỉ có thể bị 'che' (hide) chứ không phải 'ghi đè' (override).", difficulty: 'Khó' },
    { question: "Làm sao để ngăn chặn một lớp bị kế thừa?", answer: "Sử dụng từ khóa `final` trước khai báo lớp. (VD: `public final class MyClass {...}`)", difficulty: 'Trung bình' },
    { question: "Object class trong Java có vai trò gì?", answer: "`Object` là lớp cha của tất cả các lớp trong Java. Nó cung cấp các phương thức cơ bản như `toString()`, `equals()`, `hashCode()`, `clone()`.", difficulty: 'Trung bình' },
    { question: "clone() method trong Java hoạt động như thế nào?", answer: "`clone()` tạo một bản sao của đối tượng. Yêu cầu lớp phải implement giao diện `Cloneable` và ghi đè phương thức `clone()`.", difficulty: 'Khó' },
    { question: "Serialization là gì?", answer: "Là quá trình chuyển đổi một đối tượng thành một chuỗi byte để lưu trữ hoặc truyền qua mạng. Lớp cần implement `Serializable`.", difficulty: 'Trung bình' },
    { question: "Singleton pattern là gì? Làm sao để tạo Singleton class?", answer: "Là pattern đảm bảo chỉ có một instance của lớp được tạo ra. Cách tạo: Dùng `private constructor` và một phương thức `static` (VD: `getInstance()`) để trả về instance duy nhất đó.", difficulty: 'Khó' },
    { question: "Sự khác nhau giữa composition và aggregation?", answer: "Cả hai đều là quan hệ 'has-a'. <ul><li><strong>Composition (Mạnh):</strong> Đối tượng con không thể tồn tại nếu thiếu đối tượng cha (VD: Phòng và Tòa nhà).</li><li><strong>Aggregation (Yếu):</strong> Đối tượng con có thể tồn tại độc lập (VD: Sinh viên và Lớp học).</li></ul>", difficulty: 'Trung bình' },
    { question: "Dependency Injection là gì?", answer: "Là một kỹ thuật (triển khai của IoC) trong đó một đối tượng nhận các phụ thuộc của nó từ bên ngoài (thường qua constructor hoặc setter) thay vì tự tạo ra chúng.", difficulty: 'Trung bình' },
    { question: "final class và final method là gì?", answer: "<ul><li>`final class`: Lớp không thể bị kế thừa.</li><li>`final method`: Phương thức không thể bị ghi đè (override).</li></ul>", difficulty: 'Trung bình' },
    { question: "Đối tượng Comparator và Comparable khác nhau như thế nào?", answer: "<ul><li><strong>Comparable:</strong> Dùng để định nghĩa 'thứ tự tự nhiên' của đối tượng. Class implement `Comparable` và ghi đè `compareTo()`.</li><li><strong>Comparator:</strong> Dùng để định nghĩa 'thứ tự tùy chỉnh'. Tạo class riêng implement `Comparator` và ghi đè `compare()`.</li></ul>", difficulty: 'Trung bình' },
    { question: "Làm thế nào để xử lý nhiều exception trong một câu lệnh catch?", answer: "Từ Java 7, dùng multi-catch block: `catch (IOException | SQLException ex) { ... }`.", difficulty: 'Trung bình' },
    { question: "Sự khác nhau giữa String và StringBuilder trong việc tạo và thay đổi chuỗi?", answer: "`String` là bất biến (immutable), mỗi thay đổi tạo đối tượng mới. `StringBuilder` có thể thay đổi (mutable) mà không tạo đối tượng mới, nhanh hơn khi thao tác nhiều.", difficulty: 'Trung bình' },
    { question: "Đối tượng Optional trong Java 8 là gì?", answer: "`Optional` là một container cho giá trị có thể null hoặc không null. Giúp tránh lỗi `NullPointerException` bằng cách cung cấp các method như `isPresent()`, `orElse()`.", difficulty: 'Trung bình' },
    { question: "Functional Interface là gì? Nêu ví dụ.", answer: "Là interface có *duy nhất một* phương thức trừu tượng. Dùng cho Lambda. Ví dụ: `Runnable`, `Callable`.", difficulty: 'Trung bình' },
    { question: "Lambda expression trong Java là gì?", answer: "Là một cách ngắn gọn để biểu diễn một phương thức không tên (anonymous method) dùng cho functional interface. Ví dụ: `(a, b) -> a + b`.", difficulty: 'Dễ' },
    { question: "Stream API trong Java là gì?", answer: "Là API của Java 8, cho phép xử lý các tập hợp dữ liệu (Collections) theo cách thức khai báo (declarative) và dễ đọc. Hỗ trợ các hoạt động như `filter`, `map`, `reduce`, `collect`.", difficulty: 'Trung bình' },
    { question: "Cách thức hoạt động của cơ chế 'super' trong Java?", answer: "Từ khóa `super` được sử dụng để truy cập các thành phần của lớp cha từ lớp con. Bằng cách sử dụng super, bạn có thể gọi constructor của lớp cha, truy cập các biến thành viên và phương thức của lớp cha.", difficulty: 'Dễ' },
    { question: "Sự khác biệt giữa method overload và method override trong Java là gì?", answer: "<ul><li><strong>Overload (Nạp chồng):</strong> Cùng tên, khác tham số.</li><li><strong>Override (Ghi đè):</strong> Cùng tên, cùng tham số. Lớp con định nghĩa lại lớp cha.</li></ul>", difficulty: 'Trung bình' },
    { question: "Tại sao cần sử dụng từ khóa 'this' trong Java?", answer: "Để tham chiếu đến biến instance của lớp hiện tại. Thường dùng để phân biệt biến instance và biến cục bộ/tham số có cùng tên (VD: `this.name = name`).", difficulty: 'Dễ' },
    { question: "Phân biệt giữa 'composition' và 'inheritance'?", answer: "<ul><li><strong>Inheritance (Kế thừa):</strong> Quan hệ 'is-a' (VD: Chó *là* Động vật).</li><li><strong>Composition (Sáng tác):</strong> Quan hệ 'has-a' (VD: Xe *có* Động cơ). Ưu tiên 'Composition over Inheritance'.</li></ul>", difficulty: 'Trung bình' },
    { question: "Trong Java, khi nào thì nên sử dụng abstract class và khi nào thì nên sử dụng interface?", answer: "Sử dụng abstract class khi muốn cung cấp một lớp cơ sở cho các lớp con và có thể có các phương thức trừu tượng hoặc không trừu tượng. Sử dụng interface khi muốn chỉ định các phương thức mà các lớp phải triển khai mà không cần quan tâm đến cơ chế kế thừa.", difficulty: 'Trung bình' },
    { question: "Phân biệt giữa 'static binding' và 'dynamic binding' trong Java.", answer: "Static binding xảy ra tại compile time, khi biến được gán với một lớp cụ thể. Dynamic binding xảy ra tại runtime, khi phương thức được gọi dựa trên loại đối tượng thực sự được tạo.", difficulty: 'Khó' },
    { question: "Java có hỗ trợ đa kế thừa không? Nếu không, tại sao?", answer: "Không, Java không hỗ trợ đa kế thừa *lớp* (class) để tránh 'Diamond Problem' (vấn đề kim cương - mơ hồ khi 2 lớp cha có cùng 1 method). Nhưng Java hỗ trợ đa kế thừa *interface*.", difficulty: 'Trung bình' },
    { question: "Nêu ý nghĩa của từ khóa 'final' khi sử dụng cho biến, method và class trong Java?", answer: "Khi được sử dụng cho biến, `final` biểu thị rằng biến đó là hằng số. Khi được sử dụng cho method, `final` biểu thị rằng method đó không thể bị ghi đè. Khi được sử dụng cho class, `final` biểu thị rằng class đó không thể được kế thừa.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để tạo một immutable class trong Java?", answer: "1. Khai báo tất cả các biến instance là `private` và `final`.<br>2. Không cung cấp bất kỳ phương thức `setter` nào.", difficulty: 'Trung bình' },
    { question: "Tại sao việc sử dụng 'mutable' fields trong một class không được khuyến khích?", answer: "Sử dụng các trường dữ liệu có thể thay đổi có thể dẫn đến sự không ổn định và khó kiểm soát. Chúng có thể bị thay đổi bởi các phần mềm khác mà không có kiểm soát, dẫn đến sự phụ thuộc không mong muốn và kết quả không nhất quán.", difficulty: 'Trung bình' },
    { question: "Java có hỗ trợ 'multiple inheritance' thông qua interface không? Nếu có, làm thế nào?", answer: "Có. Một lớp có thể `implements` nhiều interface. Điều này cho phép một lớp có thể 'kế thừa' các tính năng từ nhiều nguồn khác nhau thông qua interface.", difficulty: 'Trung bình' },
    { question: "Trong Java, khi nào thì nên sử dụng 'abstract method'?", answer: "Abstract method nên được sử dụng khi bạn muốn yêu cầu các lớp con cung cấp một triển khai cho phương thức nhất định mà không cung cấp một triển khai mặc định.", difficulty: 'Trung bình' },
    { question: "Tại sao cần sử dụng 'instance variables' trong Java?", answer: "Instance variables (biến instance) được sử dụng để lưu trữ thông tin riêng biệt cho mỗi đối tượng và định nghĩa trạng thái của đối tượng đó.", difficulty: 'Dễ' },
    { question: "Làm thế nào để giới hạn việc khởi tạo đối tượng chỉ một lần trong Java?", answer: "Bằng cách sử dụng **Singleton Pattern**. Pattern này đảm bảo rằng chỉ có một đối tượng duy nhất của lớp được tạo ra.", difficulty: 'Khó' },
    { question: "Phương thức equals() và hashCode() có vai trò gì trong Java?", answer: "<ul><li>`equals()`: So sánh nội dung 2 đối tượng.</li><li>`hashCode()`: Trả về mã băm, dùng trong `HashMap`, `HashSet`.</li></ul><strong>Quy tắc:</strong> Nếu `equals()` true thì `hashCode()` phải bằng nhau.", difficulty: 'Khó' },
    { question: "Làm thế nào để implement một immutable class trong Java?", answer: "1. Khai báo tất cả các trường dữ liệu là `private` và `final`.<br>2. Không cung cấp `setter` methods.<br>3. Đảm bảo rằng không có phương thức nào có thể thay đổi trạng thái của đối tượng.<br>4. Nếu có biến là object (mutable), phải trả về bản sao (copy) của nó trong getter.", difficulty: 'Khó' },
    { question: "Tại sao không thể kế thừa từ class String trong Java?", answer: "Vì lớp `String` được khai báo là `final` ( `public final class String` ).", difficulty: 'Trung bình' },
    { question: "Trong Java, ngoại lệ là gì và làm thế nào để xử lý chúng?", answer: "Ngoại lệ là sự kiện bất thường xảy ra trong quá trình thực thi. Xử lý bằng khối `try-catch-finally`.", difficulty: 'Dễ' },
    { question: "Làm thế nào để so sánh hai đối tượng trong Java?", answer: "Dùng `equals()` để so sánh nội dung. Cần override `equals()` và `hashCode()` để so sánh tùy chỉnh.", difficulty: 'Trung bình' },
    { question: "Tại sao cần sử dụng 'polymorphism' (Đa hình)?", answer: "Giúp viết code linh hoạt và dễ mở rộng. Ta có thể viết code tương tác với một kiểu cha (VD: `Animal animal = new Dog()`), và code đó vẫn chạy đúng khi thay thế bằng các kiểu con khác (VD: `new Cat()`).", difficulty: 'Trung bình' },
    { question: "Java có hỗ trợ 'operator overloading' không? Nếu không, tại sao?", answer: "Không. Java không hỗ trợ nạp chồng toán tử (trừ toán tử `+` cho String) để giữ cho ngôn ngữ đơn giản và tránh nhầm lẫn.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để tạo một 'nested class' trong Java?", answer: "Khai báo một lớp bên trong một lớp khác. Có 4 loại: static nested class, inner class (non-static), local inner class (trong phương thức), và anonymous inner class (không tên).", difficulty: 'Trung bình' },
    { question: "Trong Java, từ khóa 'synchronized' được sử dụng để làm gì?", answer: "Dùng để kiểm soát truy cập đồng thời vào tài nguyên chia sẻ. Nó đảm bảo rằng chỉ một luồng (thread) có thể thực thi một khối mã hoặc phương thức tại một thời điểm.", difficulty: 'Khó' },
    { question: "Tại sao không nên sử dụng 'magic numbers' trong mã nguồn Java?", answer: "Magic numbers (các giá trị số trực tiếp) làm cho mã khó đọc, khó bảo trì. Nên sử dụng các hằng số (constants) có tên rõ ràng để thay thế.", difficulty: 'Dễ' },
    { question: "Làm thế nào để tạo một 'immutable wrapper class' trong Java?", answer: "Tạo một lớp bao bọc (wrapper) một đối tượng mutable. Lớp wrapper này phải là `final`, các trường `private final`, và không có method setter. Các method getter trả về bản sao (copy) của đối tượng bên trong.", difficulty: 'Khó' },
    { question: "Phân biệt giữa 'static method' và 'instance method' trong Java?", answer: "<ul><li><strong>Static method:</strong> Thuộc về Lớp. Gọi bằng `TenLop.method()`. Không thể truy cập biến instance.</li><li><strong>Instance method:</strong> Thuộc về Đối tượng. Phải tạo `new` để gọi. Có thể truy cập biến instance và biến static.</li></ul>", difficulty: 'Trung bình' },
    { question: "Trong Java, tại sao nên sử dụng 'constructor'?", answer: "Constructor được sử dụng để khởi tạo trạng thái ban đầu cho một đối tượng khi nó được tạo ra. Nó đảm bảo đối tượng luôn ở trạng thái hợp lệ ngay sau khi khởi tạo.", difficulty: 'Dễ' },
    { question: "Làm thế nào để tạo một 'anonymous inner class' trong Java?", answer: "Tạo một instance của interface hoặc abstract class và triển khai các phương thức của nó ngay tại chỗ. Ví dụ: `new Runnable() { public void run() { ... } }`.", difficulty: 'Trung bình' },
    { question: "Java có hỗ trợ 'method overloading' cho constructor không? Nếu có, làm thế nào?", answer: "Có. Giống như phương thức, bạn có thể định nghĩa nhiều constructor trong cùng một lớp, miễn là chúng có danh sách tham số khác nhau.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để sử dụng 'enum' trong Java?", answer: "Dùng từ khóa `enum` để định nghĩa một tập hợp các hằng số cố định. Ví dụ: `public enum Weekday { MONDAY, TUESDAY... }`.", difficulty: 'Dễ' },
    { question: "Trong Java, cách thức hoạt động của 'interface default method' là gì?", answer: "(Từ Java 8) Là phương thức có thân hàm (implementation) ngay trong interface, sử dụng từ khóa `default`. Các lớp implement interface đó có thể sử dụng phương thức này mà không cần override.", difficulty: 'Trung bình' },
    { question: "Tại sao việc sử dụng 'nested classes' trong Java được khuyến khích?", answer: "Giúp tổ chức mã logic, tăng tính đóng gói (encapsulation) vì inner class có thể truy cập thành viên `private` của lớp bên ngoài.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để tránh 'memory leaks' trong Java?", answer: "Đảm bảo giải phóng các tham chiếu không còn sử dụng (set về `null`), đóng tài nguyên (streams, connections) trong khối `finally`, cẩn thận với biến `static`.", difficulty: 'Khó' },
    { question: "Trong Java, cách thức hoạt động của 'inner class' là gì?", answer: "Inner class (non-static) là lớp lồng bên trong lớp khác. Mỗi instance của inner class gắn liền với một instance của lớp ngoài và có thể truy cập `private` members của lớp ngoài.", difficulty: 'Trung bình' },
    { question: "Tại sao cần sử dụng 'interfaces' trong lập trình hướng đối tượng?", answer: "Interfaces định nghĩa một 'hợp đồng' (contract) mà các lớp phải tuân theo, cho phép đạt được tính trừu tượng hoàn toàn và đa kế thừa (hành vi).", difficulty: 'Trung bình' },
    { question: "Trong Java, làm thế nào để truy cập các thành phần 'private' của một class từ class khác?", answer: "Không thể truy cập trực tiếp. Phải thông qua các phương thức `public` (getter/setter) mà lớp đó cung cấp (tính đóng gói).", difficulty: 'Dễ' },
    { question: "Làm thế nào để sử dụng 'inner class' để đạt được 'encapsulation' trong Java?", answer: "Inner class có thể truy cập trực tiếp thành viên `private` của lớp ngoài, giúp thực hiện logic phức tạp mà không cần 'hở' các thành viên đó ra bên ngoài.", difficulty: 'Trung bình' },
    { question: "Tại sao việc sử dụng 'default constructor' được khuyến khích trong Java?", answer: "Nếu không khai báo constructor nào, Java tự tạo default constructor. Nó hữu ích cho việc khởi tạo đối tượng đơn giản hoặc khi các framework (như Hibernate) cần tạo đối tượng.", difficulty: 'Dễ' },
    { question: "Làm thế nào để tạo một 'immutable field' trong Java?", answer: "Khai báo trường (field) là `private` và `final`, và khởi tạo nó trong constructor hoặc ngay khi khai báo.", difficulty: 'Trung bình' },
    { question: "Trong Java, cách thức hoạt động của 'method overriding' là gì?", answer: "Là khi lớp con cung cấp một triển khai cụ thể cho phương thức đã được định nghĩa ở lớp cha. Phương thức phải có cùng tên, tham số và kiểu trả về.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để tạo một 'abstract class' trong Java?", answer: "Sử dụng từ khóa `abstract` trước `class`. Lớp này không thể bị khởi tạo (`new`) và có thể chứa các `abstract method`.", difficulty: 'Dễ' },
    { question: "Tại sao việc sử dụng 'composition over inheritance' được khuyến khích trong Java?", answer: "Vì Composition linh hoạt hơn Kế thừa. Kế thừa tạo ra mối quan hệ cứng (compile-time), trong khi Composition cho phép thay đổi hành vi lúc run-time và giảm sự phụ thuộc.", difficulty: 'Khó' },
    { question: "Trong Java, tại sao không nên sử dụng 'mutable objects' như là 'key' trong một 'hashmap'?", answer: "Vì nếu đối tượng (key) bị thay đổi sau khi đưa vào HashMap, `hashCode()` của nó có thể thay đổi. Điều này làm cho HashMap không thể tìm thấy key đó nữa.", difficulty: 'Khó' },
    { question: "Làm thế nào để implement một 'builder pattern' trong Java?", answer: "Tạo một lớp `Builder` (thường là static nested class). Lớp Builder có các method setter trả về chính nó (`return this;`) và một method `build()` để tạo ra đối tượng cuối cùng.", difficulty: 'Khó' },
    { question: "Trong Java, làm thế nào để tạo một 'anonymous class'?", answer: "Là một inner class không có tên, được khai báo và khởi tạo cùng lúc, thường dùng để implement interface hoặc abstract class. (VD: `new Runnable() { ... }`).", difficulty: 'Trung bình' },
    { question: "Tại sao cần sử dụng 'factory pattern' trong lập trình hướng đối tượng?", answer: "Để che giấu logic phức tạp của việc khởi tạo đối tượng. Client chỉ cần gọi Factory mà không cần biết chính xác lớp cụ thể nào (`new Dog()`) được tạo ra.", difficulty: 'Khó' },
    
    // Database Căn Bản (JDBC, JPA)
    { question: "JDBC là gì?", answer: "JDBC (Java Database Connectivity) là một API chuẩn để kết nối và thực hiện các thao tác trên cơ sở dữ liệu từ Java.", difficulty: 'Dễ' },
    { question: "Nêu các bước kết nối đến cơ sở dữ liệu bằng JDBC.", answer: "1. Nạp driver JDBC.<br>2. Tạo kết nối (Connection).<br>3. Tạo đối tượng Statement.<br>4. Thực thi câu lệnh SQL.<br>5. Xử lý kết quả trả về (ResultSet).<br>6. Đóng kết nối.", difficulty: 'Dễ' },
    { question: "DriverManager là gì? Nó hoạt động như thế nào?", answer: "DriverManager là lớp quản lý các driver JDBC và thiết lập các kết nối đến cơ sở dữ liệu.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để nạp driver JDBC?", answer: "Dùng `Class.forName(\"com.mysql.cj.jdbc.Driver\");` (ví dụ cho MySQL).", difficulty: 'Dễ' },
    { question: "Connection là gì? Làm thế nào để tạo một Connection?", answer: "Connection là đối tượng đại diện cho kết nối đến CSDL. Tạo bằng `DriverManager.getConnection(url, user, password);`.", difficulty: 'Dễ' },
    { question: "Statement, PreparedStatement, và CallableStatement khác nhau thế nào?", answer: "<ul><li><strong>Statement:</strong> Dùng cho câu lệnh SQL tĩnh. Bị SQL Injection.</li><li><strong>PreparedStatement:</strong> Dùng cho câu lệnh SQL động (có tham số '?'), được biên dịch trước, hiệu suất tốt hơn và chống được SQL Injection.</li><li><strong>CallableStatement:</strong> Dùng để gọi các Stored Procedure.</li></ul>", difficulty: 'Trung bình' },
    { question: "Kết nối cơ sở dữ liệu với MySQL như thế nào?", answer: "Dùng `DriverManager.getConnection(\"jdbc:mysql://hostname:port/dbname\", \"username\", \"password\");`.", difficulty: 'Dễ' },
    { question: "SQL Injection là gì? Làm thế nào để ngăn chặn?", answer: "Là kỹ thuật tấn công chèn mã SQL độc hại vào câu lệnh SQL hợp lệ. Ngăn chặn bằng cách luôn luôn sử dụng `PreparedStatement`.", difficulty: 'Khó' },
    { question: "ResultSet là gì? Các kiểu ResultSet nào có sẵn trong JDBC?", answer: "ResultSet là đối tượng đại diện cho tập hợp kết quả trả về từ câu lệnh SQL. Các kiểu: `TYPE_FORWARD_ONLY`, `TYPE_SCROLL_INSENSITIVE`, `TYPE_SCROLL_SENSITIVE`.", difficulty: 'Trung bình' },
    { question: "Batch processing trong JDBC là gì?", answer: "Batch processing cho phép thực thi nhiều câu lệnh SQL cùng lúc, giảm số lượng kết nối tới CSDL và tăng hiệu suất.", difficulty: 'Trung bình' },
    { question: "Metadata là gì? DatabaseMetaData và ResultSetMetaData khác nhau thế nào?", answer: "Metadata là dữ liệu về dữ liệu. `DatabaseMetaData` cung cấp thông tin về CSDL. `ResultSetMetaData` cung cấp thông tin về cấu trúc của kết quả (tên cột, kiểu dữ liệu...)." , difficulty: 'Trung bình' },
    { question: "Làm thế nào để giao dịch (transaction) trong JDBC?", answer: "Sử dụng các phương thức `connection.setAutoCommit(false)`, `connection.commit()`, và `connection.rollback()`.", difficulty: 'Trung bình' },
    { question: "Commit và rollback trong JDBC là gì?", answer: "<ul><li><strong>Commit:</strong> Xác nhận và lưu các thay đổi trong giao dịch.</li><li><strong>Rollback:</strong> Hoàn tác các thay đổi trong giao dịch khi có lỗi.</li></ul>", difficulty: 'Trung bình' },
    { question: "Làm thế nào để xử lý các ngoại lệ JDBC?", answer: "Sử dụng khối `try-catch` để bắt và xử lý `SQLException`.", difficulty: 'Dễ' },
    { question: "Sử dụng DataSource trong JDBC như thế nào?", answer: "`DataSource` cung cấp cơ chế tốt hơn để quản lý kết nối, hỗ trợ connection pooling. Cấu hình DataSource, sau đó dùng `dataSource.getConnection()`.", difficulty: 'Trung bình' },
    { question: "Connection Pooling là gì?", answer: "Connection Pooling là kỹ thuật tái sử dụng các kết nối đã tồn tại để giảm thời gian tạo kết nối mới và tăng hiệu suất ứng dụng.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để tối ưu hóa kết nối cơ sở dữ liệu trong ứng dụng Java?", answer: "Sử dụng connection pooling, hạn chế tạo/đóng kết nối, tối ưu hóa câu lệnh SQL, dùng `PreparedStatement`.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để đọc dữ liệu từ cơ sở dữ liệu MySQL?", answer: "Sử dụng `PreparedStatement` để thực thi `SELECT`, sau đó dùng `ResultSet` để duyệt qua `while(rs.next()) { ... }`.", difficulty: 'Dễ' },
    { question: "Làm thế nào để ghi dữ liệu vào cơ sở dữ liệu MySQL?", answer: "Sử dụng `PreparedStatement` để thực thi câu lệnh `INSERT`.", difficulty: 'Dễ' },
    { question: "Làm thế nào để cập nhật dữ liệu trong cơ sở dữ liệu MySQL?", answer: "Sử dụng `PreparedStatement` để thực thi câu lệnh `UPDATE`.", difficulty: 'Dễ' },
    { question: "Làm thế nào để xóa dữ liệu trong cơ sở dữ liệu MySQL?", answer: "Sử dụng `PreparedStatement` để thực thi câu lệnh `DELETE`.", difficulty: 'Dễ' },
    { question: "Stored Procedure là gì? Làm thế nào để gọi một stored procedure từ Java?", answer: "Là một tập hợp các câu lệnh SQL được lưu trữ trong CSDL. Gọi từ Java bằng `CallableStatement`.", difficulty: 'Trung bình' },
    { question: "Sự khác nhau giữa execute, executeQuery và executeUpdate trong JDBC?", answer: "<ul><li>`executeQuery()`: Dùng cho `SELECT`. Trả về `ResultSet`.</li><li>`executeUpdate()`: Dùng cho `INSERT`, `UPDATE`, `DELETE`. Trả về `int` (số dòng bị ảnh hưởng).</li><li>`execute()`: Dùng cho mọi loại. Trả về `boolean` (true nếu có `ResultSet`).</li></ul>", difficulty: 'Trung bình' },
    { question: "Làm thế nào để thực hiện truy vấn có tham số bằng PreparedStatement?", answer: "Dùng dấu `?` trong câu SQL. Sau đó dùng các method `set...()` (ví dụ `setString`, `setInt`) để gán giá trị cho tham số.", difficulty: 'Dễ' },
    { question: "Làm thế nào để thực hiện truy vấn nhiều bảng trong MySQL từ Java?", answer: "Viết câu lệnh SQL `JOIN` (INNER JOIN, LEFT JOIN...) và thực thi nó qua `PreparedStatement`.", difficulty: 'Trung bình' },
    { question: "Cách làm việc với BLOB và CLOB trong JDBC như thế nào?", answer: "<ul><li><strong>BLOB (Binary):</strong> Dùng `setBlob()` hoặc `setBinaryStream()` để ghi, `getBlob()` hoặc `getBinaryStream()` để đọc (dữ liệu file, ảnh).</li><li><strong>CLOB (Character):</strong> Dùng `setClob()` hoặc `setCharacterStream()` để ghi, `getClob()` hoặc `getCharacterStream()` để đọc (dữ liệu text lớn).</li></ul>", difficulty: 'Khó' },
    { question: "Làm thế nào để xử lý các sự kiện (events) trong cơ sở dữ liệu từ Java?", answer: "Thường không xử lý trực tiếp từ JDBC. Dùng Trigger trong CSDL để kích hoạt. Java có thể gọi Stored Procedure để kích hoạt sự kiện gián tiếp.", difficulty: 'Khó' },
    { question: "Làm thế nào để sử dụng transaction isolation level trong JDBC?", answer: "Dùng `connection.setTransactionIsolation(level)`. Các mức: `READ_UNCOMMITTED`, `READ_COMMITTED`, `REPEATABLE_READ`, `SERIALIZABLE`.", difficulty: 'Khó' },
    { question: "ORM là gì? Hibernate là gì?", answer: "<ul><li><strong>ORM (Object-Relational Mapping):</strong> Là kỹ thuật ánh xạ các đối tượng (Object) trong lập trình hướng đối tượng với các bảng (Relational) trong CSDL quan hệ.</li><li><strong>Hibernate:</strong> Là một framework ORM mã nguồn mở, phổ biến, giúp tự động hóa các thao tác CRUD.</li></ul>", difficulty: 'Trung bình' },
    { question: "Sự khác nhau giữa JDBC và Hibernate?", answer: "JDBC là API cấp thấp, phải viết SQL thủ công. Hibernate là ORM cấp cao, tự động sinh SQL, làm việc trực tiếp với đối tượng Java, hỗ trợ caching, HQL.", difficulty: 'Trung bình' },
    { question: "Hibernate Entity là gì?", answer: "Entity class là một lớp POJO (Plain Old Java Object) đại diện cho một bảng trong cơ sở dữ liệu. Được ánh xạ bằng các annotation (`@Entity`).", difficulty: 'Trung bình' },
    { question: "Hibernate Session là gì? Làm thế nào để quản lý Session trong Hibernate?", answer: "`Session` là đối tượng chính trong Hibernate để thực hiện các thao tác CRUD, truy vấn và quản lý các transaction. Nó *không* an toàn đa luồng (not thread-safe).", difficulty: 'Trung bình' },
    { question: "HQL (Hibernate Query Language) là gì?", answer: "HQL là ngôn ngữ truy vấn hướng đối tượng, tương tự SQL nhưng hoạt động trên các *đối tượng* (Entity) và *thuộc tính* của Java thay vì các bảng và cột của CSDL.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để cấu hình Hibernate với MySQL?", answer: "Sử dụng tệp cấu hình `hibernate.cfg.xml` hoặc `application.properties` (trong Spring) để thiết lập kết nối (driver, url, user, pass) và dialect.", difficulty: 'Dễ' },
    { question: "Mapping trong Hibernate là gì? Các kiểu mapping nào có sẵn?", answer: "Mapping là quá trình ánh xạ thuộc tính của lớp Java với cột của bảng CSDL, và quan hệ giữa các lớp. Các kiểu: `@OneToOne`, `@OneToMany`, `@ManyToOne`, `@ManyToMany`.", difficulty: 'Trung bình' },
    { question: "Hibernate caching là gì? Có những loại cache nào?", answer: "Là kỹ thuật lưu trữ dữ liệu tạm thời để giảm truy vấn CSDL. <ul><li><strong>L1 (First Level Cache):</strong> Mặc định, gắn liền với `Session`.</li><li><strong>L2 (Second Level Cache):</strong> Tùy chọn, gắn liền với `SessionFactory`, chia sẻ giữa các session.</li></ul>", difficulty: 'Khó' },
    { question: "Làm thế nào để thực hiện CRUD operation với Hibernate?", answer: "Dùng các phương thức của `Session`: `save()`, `update()`, `delete()`, `get()`, `load()`.", difficulty: 'Dễ' },
    { question: "JPA (Java Persistence API) là gì?", answer: "JPA là một *tiêu chuẩn* (Specification) của Java cho ORM. Nó định nghĩa các interface và annotation. Hibernate là một *triển khai* (Implementation) phổ biến của JPA.", difficulty: 'Trung bình' },
    { question: "Sự khác nhau giữa JPA và Hibernate?", answer: "JPA là tiêu chuẩn (chỉ có interface, annotation). Hibernate là thư viện (cung cấp code triển khai JPA + các tính năng mở rộng riêng).", difficulty: 'Trung bình' },
    { question: "Entity Manager trong JPA là gì?", answer: "`EntityManager` là API chính trong JPA (tương đương với `Session` của Hibernate) để tương tác với CSDL (persist, merge, remove, find).", difficulty: 'Trung bình' },
    { question: "JPQL (Java Persistence Query Language) là gì?", answer: "Là ngôn ngữ truy vấn của JPA (tương tự HQL). Hoạt động trên các thực thể (Entity) JPA.", difficulty: 'Trung bình' },
    { question: "Persistence Context trong JPA là gì?", answer: "Là một tập hợp các thực thể (Entity) được `EntityManager` quản lý. Mọi thay đổi trên entity trong Context sẽ được tự động đồng bộ xuống CSDL khi transaction commit.", difficulty: 'Khó' },
    { question: "Làm thế nào để sử dụng annotations trong JPA?", answer: "Dùng các annotation như `@Entity`, `@Table`, `@Id`, `@GeneratedValue`, `@Column` để ánh xạ lớp Java với bảng CSDL.", difficulty: 'Dễ' },
    { question: "Spring Data JPA là gì?", answer: "Là một phần của Spring Framework, giúp đơn giản hóa việc truy cập CSDL bằng JPA. Nó cung cấp các `Repository` interface (VD: `JpaRepository`) tự động tạo code CRUD.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để tích hợp Spring với Hibernate?", answer: "Spring Boot tự động cấu hình Hibernate khi có `spring-boot-starter-data-jpa`. Chỉ cần khai báo `application.properties` và tạo Repository.", difficulty: 'Dễ' },
    { question: "Làm thế nào để xử lý ngoại lệ trong Hibernate?", answer: "Hibernate ném ra các `RuntimeException` (thường là `HibernateException`). Spring chuyển đổi chúng thành các `DataAccessException` (nhất quán hơn).", difficulty: 'Trung bình' },
    { question: "N+1 Select problem trong Hibernate là gì? Làm thế nào để tránh nó?", answer: "Là vấn đề hiệu suất khi lấy 1 danh sách (1 query), nhưng lại thực hiện thêm N câu truy vấn để lấy dữ liệu liên quan (do Lazy Loading).<br><strong>Cách tránh:</strong> Dùng `JOIN FETCH` trong JPQL/HQL.", difficulty: 'Khó' },
    { question: "Làm thế nào để tối ưu hóa hiệu suất trong Hibernate?", answer: "Sử dụng Caching (L1, L2), dùng Lazy Loading hợp lý, tránh N+1, tối ưu HQL, dùng batch processing.", difficulty: 'Khó' },
    { question: "Làm thế nào để sử dụng các công cụ ORM khác như MyBatis?", answer: "MyBatis không phải là ORM thuần túy, nó là 'SQL Mapper'. Nó ánh xạ kết quả SQL (viết tay) vào đối tượng Java, cho phép kiểm soát SQL tốt hơn.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để thực hiện join query với Hibernate?", answer: "Dùng HQL/JPQL với từ khóa `JOIN` (VD: `SELECT p FROM Post p JOIN p.comments c`) hoặc dùng `JOIN FETCH` để tải đồng thời.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để quản lý các phiên làm việc (session) trong ứng dụng Spring Boot với Hibernate?", answer: "Spring Boot (với Spring Data JPA) tự động quản lý Session/EntityManager. Mỗi transaction (thường là mỗi request web) sẽ có một session riêng.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để gọi stored procedure từ Java?", answer: "Sử dụng `CallableStatement` (JDBC) hoặc dùng `@NamedStoredProcedureQuery` (JPA).", difficulty: 'Trung bình' },
    { question: "Làm thế nào để lấy các giá trị trả về từ stored procedure?", answer: "Dùng `registerOutParameter()` của `CallableStatement`.", difficulty: 'Trung bình' },
    { question: "PreparedStatement sử dụng như thế nào?", answer: "Tạo đối tượng `PreparedStatement` từ `Connection`, thiết lập tham số (`set...()`), thực thi câu lệnh.", difficulty: 'Dễ' },
    { question: "Kể tên một số thư viện ORM phổ biến trong Java.", answer: "Hibernate (phổ biến nhất, triển khai JPA), EclipseLink (triển khai JPA), MyBatis (SQL Mapper).", difficulty: 'Dễ' },
    
    // Java IO & String
    { question: "Java IO là gì?", answer: "Java IO (Input/Output) là một API trong Java được sử dụng để đọc và ghi dữ liệu từ và vào các nguồn khác nhau như tệp tin, luồng dữ liệu, và các thiết bị.", difficulty: 'Dễ' },
    { question: "Phân biệt giữa Input và Output trong Java IO?", answer: "Input là quá trình đọc dữ liệu từ một nguồn (file, network) vào chương trình. Output là quá trình ghi dữ liệu từ chương trình ra một nguồn.", difficulty: 'Dễ' },
    { question: "InputStream và OutputStream trong Java là gì?", answer: "Đây là các lớp trừu tượng (abstract class) cơ sở cho việc đọc và ghi dữ liệu nhị phân (byte-based streams).", difficulty: 'Dễ' },
    { question: "FileReader và FileWriter trong Java làm gì?", answer: "Đây là các lớp dùng để đọc và ghi dữ liệu ký tự (character-based streams) từ/vào tệp tin văn bản.", difficulty: 'Dễ' },
    { question: "BufferedReader và BufferedWriter trong Java là gì?", answer: "Là các lớp 'wrapper' (bao bọc) cung cấp bộ đệm (buffer) cho các Reader/Writer khác. Chúng tăng hiệu suất đọc/ghi bằng cách giảm số lần truy cập vật lý, và `BufferedReader` có thêm method `readLine()`.", difficulty: 'Trung bình' },
    { question: "FileInputStream và FileOutputStream trong Java là gì?", answer: "Dùng để đọc và ghi dữ liệu nhị phân (byte) từ/vào tệp tin. Thường dùng cho file ảnh, audio, file thực thi.", difficulty: 'Dễ' },
    { question: "DataInputStream và DataOutputStream trong Java là gì?", answer: "Bao bọc các stream khác, cho phép đọc/ghi các kiểu dữ liệu nguyên thủy của Java (như `int`, `double`, `boolean`) trực tiếp thay vì byte.", difficulty: 'Trung bình' },
    { question: "RandomAccessFile trong Java làm gì?", answer: "Cho phép đọc và ghi dữ liệu tại bất kỳ vị trí nào trong tệp tin (giống như mảng). Nó hỗ trợ con trỏ tệp (file pointer).", difficulty: 'Trung bình' },
    { question: "ByteArrayOutputStream và ByteArrayInputStream trong Java là gì?", answer: "Dùng để đọc/ghi dữ liệu từ/vào một mảng byte trong bộ nhớ, thay vì tệp tin. Rất hữu ích cho việc thao tác dữ liệu tạm thời.", difficulty: 'Trung bình' },
    { question: "InputStreamReader và OutputStreamWriter trong Java là gì?", answer: "Là các 'cầu nối' (bridges) chuyển đổi giữa Stream (nhị phân, byte) và Reader/Writer (ký tự), cho phép chỉ định bộ mã (Charset, vd: UTF-8).", difficulty: 'Trung bình' },
    { question: "Java String là gì?", answer: "Java String là một lớp đại diện cho chuỗi ký tự. Nó là đối tượng và bất biến (immutable).", difficulty: 'Dễ' },
    { question: "String Pool trong Java là gì?", answer: "String Pool (hoặc String Constant Pool) là một vùng nhớ đặc biệt trong Heap (hoặc Metaspace từ Java 8) lưu trữ các chuỗi ký tự (String literals). Giúp tiết kiệm bộ nhớ bằng cách tái sử dụng chuỗi.", difficulty: 'Trung bình' },
    { question: "Immutable String trong Java là gì?", answer: "Immutable (Bất biến) có nghĩa là một khi đối tượng String được tạo, nội dung của nó không thể bị thay đổi. Mọi thao tác (nối, thay thế) đều tạo ra một đối tượng String mới.", difficulty: 'Trung bình' },
    { question: "Cách tạo một String trong Java?", answer: "1. Dùng literal (khuyến khích, sử dụng String Pool): `String s1 = \"Hello\";`<br>2. Dùng từ khóa `new` (luôn tạo object mới ngoài pool): `String s2 = new String(\"Hello\");`.", difficulty: 'Dễ' },
    { question: "Làm thế nào để so sánh hai chuỗi trong Java?", answer: "Dùng `equals()` để so sánh nội dung (giá trị). Dùng `==` để so sánh địa chỉ bộ nhớ (tham chiếu). Dùng `equalsIgnoreCase()` để so sánh không phân biệt hoa/thường.", difficulty: 'Dễ' },
    { question: "Làm thế nào để nối chuỗi trong Java?", answer: "Dùng toán tử `+`, phương thức `concat()`, hoặc dùng `StringBuilder` (hiệu suất tốt nhất nếu nối nhiều chuỗi).", difficulty: 'Dễ' },
    { question: "Phương thức intern() trong Java String là gì?", answer: "Phương thức `intern()` trả về tham chiếu của chuỗi từ String Pool. Nếu chuỗi chưa có trong pool, nó sẽ thêm vào và trả về tham chiếu.", difficulty: 'Khó' },
    { question: "Phương thức substring() trong Java String là gì?", answer: "Dùng để trích xuất một chuỗi con từ chuỗi gốc. `substring(int beginIndex)` hoặc `substring(int beginIndex, int endIndex)`.", difficulty: 'Dễ' },
    { question: "Làm thế nào để chuyển đổi một chuỗi thành một số trong Java?", answer: "Dùng các phương thức static của lớp Wrapper: `Integer.parseInt(str)`, `Double.parseDouble(str)`, `Long.parseLong(str)`.", difficulty: 'Dễ' },
    
    // Java Swing
    { question: "Java Swing là gì?", answer: "Java Swing là một bộ công cụ (toolkit) GUI (Giao diện người dùng đồ họa) cho Java, là một phần của Java Foundation Classes (JFC). Nó cung cấp các thành phần nhẹ (lightweight) và phong phú hơn AWT.", difficulty: 'Dễ' },
    { question: "Phân biệt giữa AWT và Swing trong Java?", answer: "<ul><li><strong>AWT (Abstract Window Toolkit):</strong> Dùng các thành phần 'nặng' (heavyweight), phụ thuộc vào hệ điều hành (peer-based).</li><li><strong>Swing:</strong> Dùng thành phần 'nhẹ' (lightweight), được viết hoàn toàn bằng Java, không phụ thuộc hệ điều hành (peerless), cung cấp giao diện 'Pluggable Look and Feel'.</li></ul>", difficulty: 'Trung bình' },
    { question: "JFrame trong Java Swing là gì?", answer: "`JFrame` là cửa sổ chính của ứng dụng Swing. Nó có thanh tiêu đề, các nút thu nhỏ, phóng to, đóng.", difficulty: 'Dễ' },
    { question: "JPanel trong Java Swing là gì?", answer: "`JPanel` là một 'container' (thùng chứa) chung. Nó được dùng để nhóm các thành phần khác lại với nhau hoặc để vẽ đồ họa.", difficulty: 'Dễ' },
    { question: "JButton và JLabel trong Java Swing là gì?", answer: "<ul><li><strong>JButton:</strong> Là một nút bấm, người dùng click vào để thực hiện hành động.</li><li><strong>JLabel:</strong> Là nhãn, dùng để hiển thị văn bản hoặc hình ảnh tĩnh (không chỉnh sửa được).</li></ul>", difficulty: 'Dễ' },
    { question: "JList và JTable trong Java Swing là gì?", answer: "<ul><li><strong>JList:</strong> Hiển thị một danh sách các mục, cho phép chọn một hoặc nhiều.</li><li><strong>JTable:</strong> Hiển thị dữ liệu 2 chiều dưới dạng bảng (hàng và cột).</li></ul>", difficulty: 'Trung bình' },
    { question: "JTextField và JTextArea trong Java Swing là gì?", answer: "<ul><li><strong>JTextField:</strong> Ô nhập văn bản một dòng.</li><li><strong>JTextArea:</strong> Vùng nhập văn bản nhiều dòng.</li></ul>", difficulty: 'Dễ' },
    { question: "JCheckBox và JRadioButton trong Java Swing là gì?", answer: "<ul><li><strong>JCheckBox:</strong> Hộp kiểm, cho phép chọn hoặc bỏ chọn (chọn nhiều).</li><li><strong>JRadioButton:</strong> Nút chọn (tròn), thường đi theo nhóm (`ButtonGroup`), chỉ cho phép chọn một trong nhóm.</li></ul>", difficulty: 'Dễ' },
    { question: "JMenuBar và JPopupMenu trong Java Swing là gì?", answer: "<ul><li><strong>JMenuBar:</strong> Thanh menu (nằm ở đầu cửa sổ).</li><li><strong>JPopupMenu:</strong> Menu ngữ cảnh (chuột phải).</li></ul>", difficulty: 'Trung bình' },
    { question: "JDialog và JOptionPane trong Java Swing là gì?", answer: "<ul><li><strong>JDialog:</strong> Cửa sổ hộp thoại phụ (có thể là modal).</li><li><strong>JOptionPane:</strong> Lớp tiện ích để nhanh chóng tạo các hộp thoại đơn giản (thông báo, xác nhận, nhập liệu).</li></ul>", difficulty: 'Trung bình' },
    { question: "Làm thế nào để tạo một cửa sổ mới trong Java Swing?", answer: "Tạo một instance của `JFrame` và gọi `setVisible(true)`. (VD: `JFrame frame = new JFrame(\"Tiêu đề\"); frame.setSize(400, 300); frame.setVisible(true);`)", difficulty: 'Dễ' },
    { question: "Làm thế nào để thêm một nút vào một cửa sổ trong Java Swing?", answer: "Tạo `JButton`, sau đó thêm vào `JPanel`, rồi thêm `JPanel` vào `JFrame`. Hoặc thêm trực tiếp: `frame.add(new JButton(\"Click\"), BorderLayout.CENTER);`.", difficulty: 'Dễ' },
    { question: "Làm thế nào để xử lý sự kiện click của một nút trong Java Swing?", answer: "Sử dụng `addActionListener`. (VD: `button.addActionListener(e -> { ...hành động... });`)", difficulty: 'Dễ' },
    { question: "Làm thế nào để tạo một menu bar trong Java Swing?", answer: "Tạo `JMenuBar`, `JMenu` (VD: File), và `JMenuItem` (VD: Open). Thêm Item vào Menu, thêm Menu vào MenuBar, và set MenuBar cho `JFrame`.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để tạo một danh sách chọn trong Java Swing?", answer: "Tạo mảng dữ liệu (`String[] data = ...;`), tạo `JList` từ mảng (`JList list = new JList(data);`), và thường đặt nó vào `JScrollPane`.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để thiết lập tiêu đề của một cửa sổ trong Java Swing?", answer: "Dùng `frame.setTitle(\"Tiêu đề mới\");`.", difficulty: 'Dễ' },
    { question: "Làm thế nào để hiển thị một hộp thoại thông báo trong Java Swing?", answer: "Dùng `JOptionPane.showMessageDialog(null, \"Nội dung thông báo\");`.", difficulty: 'Dễ' },
    { question: "Làm thế nào để tạo một danh sách cuộc gọi trong Java Swing? (ComboBox)", answer: "Dùng `JComboBox`. (VD: `String[] options = ...; JComboBox combo = new JComboBox(options);`)", difficulty: 'Trung bình' },
    { question: "Làm thế nào để tạo một bảng dữ liệu trong Java Swing?", answer: "Tạo mảng dữ liệu 2 chiều (`Object[][] data`) và mảng tiêu đề cột (`String[] columns`). Tạo `JTable table = new JTable(data, columns);` và đặt vào `JScrollPane`.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để thiết lập kích thước cửa sổ trong Java Swing?", answer: "Dùng `frame.setSize(width, height);` hoặc `frame.pack()` (tự động điều chỉnh kích thước).", difficulty: 'Dễ' },
    { question: "Làm thế nào để thêm một đối tượng vào một panel trong Java Swing?", answer: "Dùng `panel.add(component);`.", difficulty: 'Dễ' },
    { question: "Làm thế nào để tạo một ứng dụng Java Swing đa luồng?", answer: "Không bao giờ cập nhật UI từ luồng khác ngoài **Event Dispatch Thread (EDT)**. Dùng `SwingUtilities.invokeLater(() -> { ...cập nhật UI... });` hoặc dùng `SwingWorker` cho các tác vụ nền.", difficulty: 'Khó' },
    { question: "Làm thế nào để sắp xếp các thành phần trong một cửa sổ Java Swing?", answer: "Sử dụng Layout Manager. Set layout cho `JPanel`: `panel.setLayout(new FlowLayout());` hoặc `new BorderLayout()`, `new GridLayout()`, `new BoxLayout()`.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để tạo một thanh cuộn trong Java Swing?", answer: "Dùng `JScrollPane`. (VD: `JTextArea area = ...; JScrollPane scroll = new JScrollPane(area);`)", difficulty: 'Dễ' },
    { question: "Làm thế nào để tạo một ô đầu vào văn bản trong Java Swing?", answer: "Dùng `JTextField` (một dòng) hoặc `JTextArea` (nhiều dòng).", difficulty: 'Dễ' },
    { question: "Làm thế nào để tạo một hộp chọn trong Java Swing?", answer: "Dùng `JCheckBox` (chọn nhiều) hoặc `JRadioButton` (chọn một).", difficulty: 'Dễ' },
    { question: "Làm thế nào để thêm một hình ảnh vào một ứng dụng Java Swing?", answer: "Dùng `ImageIcon`. (VD: `ImageIcon icon = new ImageIcon(\"path/to/image.jpg\"); JLabel label = new JLabel(icon);`)", difficulty: 'Dễ' },
    { question: "Làm thế nào để tạo một giao diện người dùng đồ họa đơn giản trong Java Swing?", answer: "Kết hợp `JFrame`, `JPanel`, `JLabel`, `JTextField`, `JButton` và Layout Manager.", difficulty: 'Dễ' },
    { question: "Làm thế nào để tạo một cửa sổ không đồng nhất (modal dialog)?", answer: "Tạo `JDialog` và set `setModal(true)`. Cửa sổ này sẽ chặn tương tác với cửa sổ cha.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để tạo một ứng dụng giao diện người dùng đa cửa sổ trong Java Swing?", answer: "Tạo nhiều instance của `JFrame` hoặc `JDialog` và quản lý chúng.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để tạo một phím tắt trong Java Swing?", answer: "Dùng `Key Bindings` (cách hiện đại) hoặc `setMnemonic()` cho `JButton` (dùng phím Alt+Ký tự).", difficulty: 'Khó' },
    { question: "Làm thế nào để làm cho một cửa sổ không thể di chuyển trong Java Swing?", answer: "Dùng `frame.setResizable(false);` (cũng ngăn thay đổi kích thước). Để chỉ ngăn di chuyển là phức tạp hơn.", difficulty: 'Dễ' },
    { question: "Làm thế nào để tạo một tiêu đề có màu trong Java Swing?", answer: "Cần tùy chỉnh 'Look and Feel' (L&F) của Java, khá phức tạp. Không thể set màu trực tiếp.", difficulty: 'Khó' },
    { question: "Làm thế nào để tạo một giao diện người dùng đa ngôn ngữ trong Java Swing?", answer: "Sử dụng `ResourceBundle` và các file `.properties` (VD: `messages_vi.properties`, `messages_en.properties`) để lưu trữ văn bản.", difficulty: 'Khó' },
    { question: "Làm thế nào để tạo một ứng dụng Swing tương tác với cơ sở dữ liệu?", answer: "Kết hợp JDBC để truy vấn CSDL (nên thực hiện trên luồng nền - `SwingWorker`) và `JTable` để hiển thị dữ liệu.", difficulty: 'Khó' },
    { question: "Làm thế nào để thêm hình ảnh nền cho một cửa sổ trong Java Swing?", answer: "Tạo một `JPanel` tùy chỉnh, override phương thức `paintComponent(Graphics g)` và dùng `g.drawImage()` để vẽ ảnh nền.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để tạo một ứng dụng Swing tự động mở cửa sổ khi khởi động?", answer: "Viết code khởi tạo `JFrame` và gọi `setVisible(true)` trong phương thức `main()`.", difficulty: 'Dễ' },
    { question: "Làm thế nào để hiển thị một cửa sổ thông báo bật lên trong Java Swing?", answer: "Dùng `JOptionPane.showMessageDialog()`.", difficulty: 'Dễ' },
    { question: "Làm thế nào để tạo một giao diện người dùng đồng nhất trên tất cả các nền tảng?", answer: "Sử dụng 'Look and Feel' của Java (VD: 'Metal') thay vì L&F của hệ thống. `UIManager.setLookAndFeel(...)`.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để tạo một thanh công cụ trong Java Swing?", answer: "Dùng `JToolBar` và thêm các `JButton` (thường là chỉ có icon) vào đó. Thêm toolbar vào `JFrame` (thường ở `BorderLayout.NORTH`).", difficulty: 'Trung bình' },
    { question: "Làm thế nào để hiển thị một tiến trình hoạt động trong Java Swing?", answer: "Dùng `JProgressBar`. Cập nhật giá trị của nó (`setValue()`) từ `SwingWorker`.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để thiết lập giới hạn cho một ô đầu vào văn bản trong Java Swing?", answer: "Sử dụng `DocumentFilter` gắn vào `Document` của `JTextField` để kiểm soát đầu vào.", difficulty: 'Khó' },
    { question: "Làm thế nào để làm cho một cửa sổ Java Swing có khả năng di chuyển?", answer: "Mặc định `JFrame` đã có thể di chuyển. Nếu bạn tắt viền (`setUndecorated(true)`), bạn phải tự implement sự kiện chuột để di chuyển nó.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để sắp xếp dữ liệu trong một bảng Java Swing?", answer: "Dùng `table.setAutoCreateRowSorter(true);` (từ Java 6). Click vào tiêu đề cột để sắp xếp.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để làm cho một ô đầu vào văn bản trong Java Swing chỉ đọc?", answer: "Dùng `textField.setEditable(false);`.", difficulty: 'Dễ' },
    { question: "Làm thế nào để làm cho một ô đầu vào văn bản trong Java Swing có thể chỉnh sửa?", answer: "Mặc định là có thể chỉnh sửa (`setEditable(true)`).", difficulty: 'Dễ' },
    { question: "Làm thế nào để thêm một hộp thoại mở tệp vào ứng dụng Java Swing?", answer: "Dùng `JFileChooser`. (VD: `JFileChooser chooser = new JFileChooser(); int result = chooser.showOpenDialog(null);`)", difficulty: 'Dễ' },
    { question: "Làm thế nào để thêm một hộp thoại lưu tệp vào ứng dụng Java Swing?", answer: "Dùng `JFileChooser` và gọi `chooser.showSaveDialog(null);`.", difficulty: 'Dễ' },
    { question: "Làm thế nào để thêm các hiệu ứng chuyển động vào các thành phần trong Java Swing?", answer: "Sử dụng `javax.swing.Timer` để cập nhật thuộc tính (vị trí, màu sắc) của component theo thời gian.", difficulty: 'Khó' },
    { question: "Làm thế nào để tạo một ô chọn màu trong Java Swing?", answer: "Dùng `JColorChooser`. (VD: `Color newColor = JColorChooser.showDialog(null, \"Chọn màu\", initialColor);`)", difficulty: 'Trung bình' },
    { question: "Làm thế nào để thiết kế một giao diện người dùng đẹp mắt trong Java Swing?", answer: "Sử dụng Layout Manager (đặc biệt là `GridBagLayout` hoặc `MigLayout`), dùng 'Look and Feel' đẹp (VD: Substance, FlatLaf), và chú ý đến khoảng cách, font chữ.", difficulty: 'Khó' },
    { question: "Làm thế nào để tạo một ứng dụng Java Swing có khả năng kéo và thả (Drag and Drop)?", answer: "Sử dụng `TransferHandler` API của Swing để quản lý việc 'drag' (export) và 'drop' (import) dữ liệu.", difficulty: 'Khó' },
    { question: "Làm thế nào để tạo một thanh trượt trong Java Swing?", answer: "Dùng `JSlider`. (VD: `JSlider slider = new JSlider(JSlider.HORIZONTAL, 0, 100, 50);`)", difficulty: 'Dễ' },
    { question: "Làm thế nào để hiển thị một danh sách dọc trong Java Swing?", answer: "Dùng `JList` (đặt trong `JScrollPane`). Mặc định nó đã hiển thị dọc.", difficulty: 'Dễ' },
    { question: "Làm thế nào để tạo một ứng dụng Swing có khả năng vẽ?", answer: "Tạo `JPanel`, override `paintComponent(Graphics g)`, và dùng các method của `Graphics` (hoặc `Graphics2D`) như `g.drawLine()`, `g.drawRect()`, `g.setColor()`.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để tạo một ứng dụng Swing có khả năng in ấn?", answer: "Sử dụng Java Print Service API. Implement interface `Printable` và định nghĩa cách vẽ component lên máy in.", difficulty: 'Khó' },
    { question: "Làm thế nào để tạo một ứng dụng Swing có khả năng xuất dữ liệu vào file PDF?", answer: "Sử dụng thư viện bên ngoài như `Apache PDFBox` hoặc `iText`. Không có sẵn trong Swing.", difficulty: 'Khó' },
    { question: "Làm thế nào để tạo một ứng dụng Swing có khả năng xuất dữ liệu vào file Excel?", answer: "Sử dụng thư viện bên ngoài như `Apache POI`. Không có sẵn trong Swing.", difficulty: 'Khó' },
    { question: "Làm thế nào để thêm hiệu ứng hover vào các thành phần trong Java Swing?", answer: "Dùng `addMouseListener` và xử lý sự kiện `mouseEntered` (vào) và `mouseExited` (ra).", difficulty: 'Trung bình' },
    { question: "Làm thế nào để tạo một ứng dụng Swing có thể thực hiện giao tiếp mạng?", answer: "Kết hợp `java.net.Socket` (cho TCP) hoặc `HttpURLConnection` (cho HTTP) trong một `SwingWorker` để tránh block EDT.", difficulty: 'Khó' },
    { question: "Làm thế nào để làm cho một cửa sổ Java Swing hiển thị ở giữa màn hình?", answer: "Dùng `frame.setLocationRelativeTo(null);` (phải gọi sau `setSize`).", difficulty: 'Dễ' },
    { question: "Làm thế nào để tạo một ứng dụng Java Swing có thể thực hiện trò chơi?", answer: "Dùng `JPanel` tùy chỉnh (override `paintComponent`) và một `javax.swing.Timer` làm vòng lặp game (game loop) để cập nhật logic và vẽ lại.", difficulty: 'Khó' },
    { question: "Làm thế nào để thêm âm thanh vào ứng dụng Java Swing?", answer: "Sử dụng Java Sound API (`javax.sound.sampled`). (VD: `AudioInputStream`, `Clip`).", difficulty: 'Trung bình' },
    { question: "Làm thế nào để làm cho một ứng dụng Java Swing chạy tự động khi khởi động máy tính?", answer: "Đây là vấn đề của Hệ điều hành, không phải của Swing. Cần thêm ứng dụng vào 'Startup folder' (Windows) hoặc `systemd`/`cron` (Linux).", difficulty: 'Khó' },
    { question: "Làm thế nào để tạo một giao diện người dùng Java Swing phản ánh theo các thiết bị đầu cuối khác nhau?", answer: "Sử dụng Layout Manager linh hoạt (như `GridBagLayout`) và tránh set kích thước cố định (`setSize`), thay vào đó dùng `setPreferredSize` và `pack()`.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để tạo một giao diện người dùng Java Swing đáp ứng (responsive)?", answer: "Tương tự câu trên, dùng Layout Manager tốt. Swing không được thiết kế cho 'responsive' như web, nhưng có thể co giãn tốt.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để thêm tooltip vào các thành phần trong Java Swing?", answer: "Dùng `component.setToolTipText(\"Đây là hướng dẫn\");`.", difficulty: 'Dễ' },
    { question: "Làm thế nào để tạo một ứng dụng Swing có khả năng gửi email?", answer: "Sử dụng thư viện JavaMail API (nay là Jakarta Mail). Cần cấu hình SMTP server.", difficulty: 'Khó' },
    { question: "Làm thế nào để tạo một ứng dụng Swing có khả năng tương tác với API web?", answer: "Sử dụng `HttpURLConnection` (có sẵn) hoặc thư viện (Apache HttpClient, OkHttp) trong `SwingWorker` để gọi API và cập nhật UI.", difficulty: 'Khó' },
    { question: "Làm thế nào để tạo một ứng dụng Swing có khả năng tải và phát trực tuyến âm nhạc?", answer: "Sử dụng Java Sound API (`javax.sound.sampled`) kết hợp với `URL` để đọc stream nhạc.", difficulty: 'Khó' },
    { question: "Làm thế nào để tạo một ứng dụng Swing có khả năng tương tác với hệ thống tập tin?", answer: "Sử dụng `java.io.File` (cũ) hoặc `java.nio.file.Files` (mới) để đọc/ghi/xóa file. Dùng `JFileChooser` để cho người dùng chọn file.", difficulty: 'Dễ' },
    { question: "Làm thế nào để tạo một ứng dụng Swing có khả năng sử dụng cảm biến?", answer: "Cần thư viện của bên thứ ba (VD: `jSerialComm` cho cổng COM) để giao tiếp với phần cứng cảm biến.", difficulty: 'Khó' },
    { question: "Làm thế nào để tạo một ứng dụng Swing có khả năng tạo và quản lý sự kiện?", answer: "Sử dụng mô hình Event-Listener của Java: tạo component (JButton), thêm Listener (`addActionListener`), viết code xử lý trong Listener.", difficulty: 'Dễ' },
    { question: "Làm thế nào để tạo một ứng dụng Swing có khả năng sử dụng cảm ứng?", answer: "Swing không hỗ trợ cảm ứng (touch events) một cách tự nhiên. Cần dùng JavaFX hoặc thư viện bên ngoài.", difficulty: 'Khó' },
    { question: "Làm thế nào để tạo một ứng dụng Swing có khả năng tương tác với máy quét mã vạch?", answer: "Máy quét mã vạch thường hoạt động như một bàn phím (Keyboard Wedge). Chỉ cần focus vào `JTextField` và máy quét sẽ tự nhập dữ liệu vào.", difficulty: 'Dễ' },
    { question: "Làm thế nào để tạo một ứng dụng Swing có khả năng in ấn nhiều trang?", answer: "Implement `Printable` interface. Trong method `print()`, kiểm tra `pageIndex` và vẽ nội dung cho trang đó. Trả về `PAGE_EXISTS` hoặc `NO_SUCH_PAGE`.", difficulty: 'Khó' },
    { question: "Làm thế nào để tạo một ứng dụng Swing có khả năng tương tác với máy in?", answer: "Sử dụng Java Print Service API (`javax.print`).", difficulty: 'Khó' },
    { question: "Làm thế nào để tạo một ứng dụng Swing có khả năng xuất dữ liệu sang máy chủ FTP?", answer: "Sử dụng thư viện bên ngoài như `Apache Commons Net` (FTPClient).", difficulty: 'Khó' },
    { question: "Làm thế nào để tạo một ứng dụng Swing có khả năng chia sẻ dữ liệu qua mạng nội bộ?", answer: "Sử dụng `java.net.Socket` (cho lập trình TCP/IP) hoặc RMI (Remote Method Invocation).", difficulty: 'Khó' },

    // Java Nâng Cao (Multithread, JVM...)
    { question: "Lambda expression trong Java có những lợi ích gì?", answer: "Cú pháp ngắn gọn hơn, giúp mã nguồn dễ đọc, dễ bảo trì, và hỗ trợ lập trình hàm (functional programming).", difficulty: 'Trung bình' },
    { question: "Method reference là gì? Cho ví dụ.", answer: "Là cú pháp ngắn gọn của Lambda expression để gọi một phương thức đã tồn tại. Ví dụ: `System.out::println` thay cho `s -> System.out.println(s)`.", difficulty: 'Trung bình' },
    { question: "Interface trong Java 8 có thể có những loại phương thức nào?", answer: "Interface có thể có phương thức `abstract` (như cũ), phương thức `default` (có thân hàm), và phương thức `static` (có thân hàm).", difficulty: 'Trung bình' },
    { question: "Stream API trong Java hỗ trợ những thao tác gì?", answer: "Stream API hỗ trợ các thao tác trung gian (intermediate) như `filter()`, `map()`, `sorted()` và thao tác kết thúc (terminal) như `collect()`, `forEach()`, `reduce()`.", difficulty: 'Trung bình' },
    { question: "Optional trong Java có những phương thức nào để xử lý giá trị null?", answer: "Các phương thức như `isPresent()`, `ifPresent()`, `orElse()`, `orElseGet()`, `orElseThrow()`.", difficulty: 'Trung bình' },
    { question: "Functional Interface trong Java có quy tắc gì đặc biệt?", answer: "Functional Interface chỉ chứa *duy nhất một* phương thức abstract. Được đánh dấu bằng `@FunctionalInterface` (tùy chọn nhưng khuyến khích).", difficulty: 'Trung bình' },
    { question: "Biểu thức lambda có thể truy cập biến local không?", answer: "Có, nhưng các biến local đó phải là `final` hoặc `effectively final` (không bị thay đổi giá trị sau khi khởi tạo).", difficulty: 'Khó' },
    { question: "Static và default method trong interface khác nhau như thế nào?", answer: "<ul><li><strong>Static method:</strong> Thuộc về interface. Gọi bằng `TenInterface.method()`. Không thể override.</li><li><strong>Default method:</strong> Thuộc về instance. Lớp implement có thể override nó.</li></ul>", difficulty: 'Trung bình' },
    { question: "Stream có thể tái sử dụng không? Tại sao?", answer: "Không. Stream là một dạng single-use. Sau khi đã thực hiện các thao tác kết thúc (terminal), Stream sẽ bị đóng và không thể dùng lại.", difficulty: 'Trung bình' },
    { question: "Parallel Stream là gì?", answer: "Parallel Stream cho phép xử lý dữ liệu đồng thời (song song) bằng cách chia nhỏ công việc ra nhiều luồng (thread), tận dụng CPU đa lõi.", difficulty: 'Trung bình' },
    { question: "Lợi ích của việc sử dụng CompletableFuture trong Java?", answer: "Cho phép thực hiện các thao tác bất đồng bộ (asynchronous) và xử lý kết quả (callback) mà không block luồng chính. Hỗ trợ kết hợp nhiều tác vụ.", difficulty: 'Khó' },
    { question: "Java 9 module system là gì?", answer: "(Project Jigsaw) Cho phép tổ chức mã nguồn thành các module độc lập. Mỗi module khai báo rõ ràng nó `requires` (cần) module nào và `exports` (xuất) package nào.", difficulty: 'Khó' },
    { question: "Phân biệt giữa module và package trong Java?", answer: "Package là nhóm các lớp. Module là một tập hợp các package, quản lý các phụ thuộc và đóng gói ở mức độ cao hơn.", difficulty: 'Trung bình' },
    { question: "Service loader trong Java 9 là gì?", answer: "Service loader là cơ chế để nạp các dịch vụ (implementations) dựa trên một interface hoặc abstract class, hỗ trợ bởi module system.", difficulty: 'Khó' },
    { question: "Reactive Streams trong Java là gì?", answer: "Reactive Streams là một API (chuẩn) để xử lý các luồng dữ liệu không đồng bộ với cơ chế 'áp lực ngược' (backpressure), giúp bên nhận kiểm soát tốc độ nhận dữ liệu.", difficulty: 'Khó' },
    { question: "Memory management trong JVM hoạt động như thế nào?", answer: "JVM quản lý bộ nhớ qua các vùng heap (lưu đối tượng) và stack (lưu biến cục bộ, gọi hàm). Garbage Collector (GC) tự động dọn dẹp heap.", difficulty: 'Trung bình' },
    { question: "Garbage Collection trong JVM hoạt động như thế nào?", answer: "GC (vd: Mark-and-Sweep) tìm các đối tượng không còn được tham chiếu (rác) và giải phóng bộ nhớ của chúng.", difficulty: 'Khó' },
    { question: "Những loại Garbage Collector nào có sẵn trong JVM?", answer: "Serial GC, Parallel GC, CMS (Concurrent Mark-Sweep) GC, G1 (Garbage First) GC, ZGC, Shenandoah GC.", difficulty: 'Khó' },
    { question: "JVM heap memory bao gồm những vùng nào?", answer: "Chủ yếu là Young Generation (Eden, S0, S1) và Old Generation (Tenured). Và Metaspace (từ Java 8, thay cho PermGen).", difficulty: 'Khó' },
    { question: "Stack Memory và Heap Memory khác nhau như thế nào?", answer: "<ul><li><strong>Stack:</strong> Lưu biến nguyên thủy, tham chiếu đối tượng, frame của phương thức. Nhanh, quản lý LIFO, giới hạn.</li><li><strong>Heap:</strong> Lưu các đối tượng (Object) được tạo bằng `new`. Lớn, được quản lý bởi GC.</li></ul>", difficulty: 'Trung bình' },
    { question: "PermGen và Metaspace trong JVM là gì?", answer: "Cả hai đều lưu metadata của lớp (thông tin về class). PermGen (trước Java 8) có kích thước cố định, dễ `OutOfMemoryError`. Metaspace (từ Java 8) dùng bộ nhớ native, tự động mở rộng.", difficulty: 'Khó' },
    { question: "Java Flight Recorder là gì?", answer: "Java Flight Recorder (JFR) là công cụ profiling tích hợp trong JVM để ghi lại thông tin chi tiết về hiệu suất và hành vi của ứng dụng với chi phí thấp.", difficulty: 'Khó' },
    { question: "Java Mission Control là gì?", answer: "Java Mission Control (JMC) là công cụ để phân tích dữ liệu được ghi lại bởi Java Flight Recorder (JFR), giúp chẩn đoán sự cố.", difficulty: 'Khó' },
    { question: "Class loader trong Java là gì?", answer: "Class loader là thành phần của JVM chịu trách nhiệm nạp các lớp (file `.class`) vào bộ nhớ tại thời điểm chạy (runtime).", difficulty: 'Trung bình' },
    { question: "Những loại class loader nào có trong JVM?", answer: "Bootstrap (tải core Java API), Extension (tải thư viện mở rộng), System/Application (tải code của ứng dụng).", difficulty: 'Trung bình' },
    { question: "Double brace initialization là gì?", answer: "Là cú pháp tạo và khởi tạo collection (VD: `new ArrayList<String>() {{ add(\"A\"); add(\"B\"); }}`). *Không khuyến khích* vì nó tạo ra 1 anonymous inner class.", difficulty: 'Trung bình' },
    { question: "Atomic classes trong Java có tác dụng gì?", answer: "(VD: `AtomicInteger`) Cung cấp các thao tác (như `incrementAndGet`) an toàn đa luồng (thread-safe) mà không cần dùng `synchronized`, hiệu suất cao hơn.", difficulty: 'Khó' },
    { question: "ConcurrentHashMap khác với HashMap như thế nào?", answer: "`ConcurrentHashMap` an toàn đa luồng, cho phép nhiều luồng đọc/ghi đồng thời (bằng cách khóa các 'segment' thay vì cả map). `HashMap` không thread-safe.", difficulty: 'Khó' },
    { question: "Thread pool là gì?", answer: "Là một tập hợp các luồng (worker threads) được tạo sẵn. Giúp tái sử dụng luồng, tránh chi phí tạo/hủy luồng liên tục, và kiểm soát số lượng luồng.", difficulty: 'Trung bình' },
    { question: "Executor framework trong Java là gì?", answer: "Là API cấp cao (VD: `ExecutorService`) để quản lý và thực thi các tác vụ (Runnable, Callable) dùng thread pool.", difficulty: 'Trung bình' },
    { question: "Fork/Join framework là gì?", answer: "(Từ Java 7) Hỗ trợ lập trình song song bằng cách áp dụng thuật toán 'chia để trị' (fork = chia nhỏ, join = kết hợp kết quả).", difficulty: 'Khó' },
    { question: "CountDownLatch là gì?", answer: "Là cơ chế đồng bộ cho phép một hoặc nhiều luồng chờ cho đến khi một tập hợp các hoạt động (được đếm bằng latch) hoàn thành.", difficulty: 'Khó' },
    { question: "CyclicBarrier là gì?", answer: "Là cơ chế đồng bộ cho phép một nhóm các luồng chờ nhau tại một 'hàng rào' (barrier) trước khi tất cả cùng tiếp tục. Có thể tái sử dụng.", difficulty: 'Khó' },
    { question: "Phân biệt giữa CountDownLatch và CyclicBarrier?", answer: "CountDownLatch dùng 1 lần (đếm về 0). CyclicBarrier có thể tái sử dụng (reset). Latch dùng cho 1 luồng chờ N luồng, Barrier dùng cho N luồng chờ nhau.", difficulty: 'Khó' },
    { question: "Semaphore là gì?", answer: "Là cơ chế đồng bộ hóa, giới hạn số lượng luồng có thể truy cập đồng thời vào một tài nguyên (giống như 'giấy phép').", difficulty: 'Khó' },
    { question: "Exchanger là gì?", answer: "Cho phép hai luồng gặp nhau và trao đổi dữ liệu (data) trực tiếp với nhau tại một điểm đồng bộ.", difficulty: 'Khó' },
    { question: "Phân biệt giữa synchronized block và synchronized method?", answer: "`synchronized method` khóa toàn bộ đối tượng (`this`). `synchronized block` chỉ khóa một phần code và có thể chọn đối tượng để khóa (linh hoạt hơn).", difficulty: 'Trung bình' },
    { question: "ReentrantLock là gì?", answer: "Là một cơ chế khóa (Lock) linh hoạt hơn `synchronized`. Nó 'reentrant' (luồng giữ khóa có thể vào lại), có thể `tryLock` (thử khóa), và tạo `Condition`.", difficulty: 'Khó' },
    { question: "Condition object trong Java là gì?", answer: "Được tạo từ `ReentrantLock`. Cung cấp các phương thức `await()` (thay cho `wait()`) và `signal()`/`signalAll()` (thay cho `notify()`/`notifyAll()`).", difficulty: 'Khó' },
    { question: "Phân biệt giữa sleep() và wait() trong Java?", answer: "<ul><li>`sleep()`: Tạm dừng luồng, **vẫn giữ khóa** (lock).</li><li>`wait()`: Tạm dừng luồng, **nhả khóa** (lock) và chờ `notify()`/`notifyAll()`.</li></ul>", difficulty: 'Khó' },
    { question: "Phân biệt giữa notify() và notifyAll() trong Java?", answer: "<ul><li>`notify()`: Đánh thức *một* luồng ngẫu nhiên đang chờ trên đối tượng.</li><li>`notifyAll()`: Đánh thức *tất cả* các luồng đang chờ. (Nên dùng `notifyAll()` để tránh rủi ro).</li></ul>", difficulty: 'Khó' },
    { question: "Làm thế nào để thực hiện Thread-safe singleton trong Java?", answer: "Dùng 'Double-checked locking' với `volatile`, dùng 'Initialization-on-demand holder idiom' (static inner class), hoặc cách đơn giản nhất: dùng `enum`.", difficulty: 'Khó' },
    { question: "Immutability trong Java là gì?", answer: "Bất biến. Là tính chất của một đối tượng không thể thay đổi trạng thái sau khi đã được tạo (VD: `String`). Rất tốt cho đa luồng.", difficulty: 'Trung bình' },
    { question: "ThreadLocal trong Java là gì?", answer: "Cung cấp một biến mà mỗi luồng có một bản sao riêng, độc lập. Giúp tránh xung đột dữ liệu giữa các luồng mà không cần `synchronized`.", difficulty: 'Khó' },
    { question: "Memory Consistency Errors là gì?", answer: "Xảy ra khi các luồng khác nhau nhìn thấy giá trị không nhất quán của cùng một biến (do caching của CPU). Dùng `volatile` hoặc `synchronized` để giải quyết.", difficulty: 'Khó' },
    { question: "ForkJoinPool là gì?", answer: "Là `ExecutorService` triển khai Fork/Join framework. `Parallel Stream` của Java 8 sử dụng ForkJoinPool chung.", difficulty: 'Khó' },
    { question: "JMX (Java Management Extensions) là gì?", answer: "Là công nghệ để giám sát (monitoring) và quản lý (management) các ứng dụng Java (VD: xem mức sử dụng Heap, CPU) qua các MBeans.", difficulty: 'Khó' },
    { question: "Phiên bản nào của Java giới thiệu VarHandle?", answer: "`VarHandle` được giới thiệu trong **Java 9**. Nó là API cấp thấp thay thế cho `Atomic` và `Unsafe` để thao tác bộ nhớ.", difficulty: 'Khó' },
    
    // Lập Trình Web (Servlet, Spring)
    { question: "Servlet là gì?", answer: "Servlet là một lớp Java chạy trên máy chủ (server-side) để xử lý các yêu cầu (request) HTTP từ client và gửi phản hồi (response) HTTP.", difficulty: 'Dễ' },
    { question: "Servlet lifecycle bao gồm những giai đoạn nào?", answer: "1. `init()`: Khởi tạo (chạy 1 lần).<br>2. `service()`: Xử lý request (chạy nhiều lần).<br>3. `destroy()`: Hủy (chạy 1 lần khi shutdown).", difficulty: 'Trung bình' },
    { question: "Đối tượng HttpServletRequest là gì?", answer: "`HttpServletRequest` chứa thông tin về yêu cầu của client (parameters, headers, URL, method...)." , difficulty: 'Dễ' },
    { question: "Đối tượng HttpServletResponse là gì?", answer: "`HttpServletResponse` dùng để gửi phản hồi về cho client (set content type, status code, ghi dữ liệu...)." , difficulty: 'Dễ' },
    { question: "Phân biệt giữa doGet() và doPost() trong Servlet?", answer: "<ul><li>`doGet()`: Xử lý yêu cầu `GET` (dữ liệu trên URL), dùng để lấy dữ liệu.</li><li>`doPost()`: Xử lý yêu cầu `POST` (dữ liệu trong body), dùng để gửi/thay đổi dữ liệu, bảo mật hơn.</li></ul>", difficulty: 'Dễ' },
    { question: "Servlet Filter là gì?", answer: "Là đối tượng có thể 'chặn' (intercept) request trước khi đến Servlet và response trước khi về client. Dùng để logging, authentication, nén dữ liệu.", difficulty: 'Trung bình' },
    { question: "Listener trong Servlet là gì?", answer: "Là đối tượng 'lắng nghe' các sự kiện trong vòng đời của ứng dụng web (VD: `ServletContextListener` khi app start/stop, `HttpSessionListener` khi session tạo/hủy).", difficulty: 'Trung bình' },
    { question: "Request Dispatcher là gì?", answer: "Được sử dụng để chuyển tiếp (forward) request từ một Servlet đến tài nguyên khác (Servlet, JSP) trên server, hoặc `include` nội dung của tài nguyên khác.", difficulty: 'Trung bình' },
    { question: "Session management trong Java Servlet như thế nào?", answer: "Dùng `HttpSession` (phổ biến nhất, server lưu `JSESSIONID` qua cookie), Cookie (client lưu), URL Rewriting (nhúng ID vào URL).", difficulty: 'Trung bình' },
    { question: "Cookie trong Servlet là gì?", answer: "Cookie là một đoạn dữ liệu nhỏ được server gửi về và lưu trữ trên trình duyệt (client) để nhận diện client trong các request sau.", difficulty: 'Dễ' },
    { question: "Spring Framework là gì?", answer: "Spring là một framework toàn diện (application framework) cho Java, cung cấp các giải pháp cho Dependency Injection (IoC), AOP, Data Access, Web (MVC).", difficulty: 'Dễ' },
    { question: "Inversion of Control (IoC) là gì?", answer: "IoC (Đảo ngược điều khiển) là nguyên lý thiết kế. Thay vì đối tượng tự tạo phụ thuộc (`new`), thì phụ thuộc được 'tiêm' (inject) vào đối tượng từ bên ngoài (bởi IoC Container).", difficulty: 'Trung bình' },
    { question: "Dependency Injection trong Spring hoạt động như thế nào?", answer: "DI là cách triển khai IoC. Spring Container (ApplicationContext) đọc cấu hình (VD: `@Component`), tự tạo các 'Bean', và 'tiêm' (inject) bean này vào bean khác qua `@Autowired` (Constructor, Setter, Field).", difficulty: 'Trung bình' },
    { question: "Bean trong Spring là gì?", answer: "Bean là một đối tượng (object) được khởi tạo, lắp ráp và quản lý bởi Spring IoC Container.", difficulty: 'Dễ' },
    { question: "Spring Bean lifecycle bao gồm những giai đoạn nào?", answer: "Instantiation (Khởi tạo) -> Populate Properties (Tiêm phụ thuộc) -> ... (Aware interfaces) -> Post-initialization (Sau khởi tạo, `@PostConstruct`) -> Ready -> Destruction (Trước khi hủy, `@PreDestroy`).", difficulty: 'Khó' },
    { question: "ApplicationContext trong Spring là gì?", answer: "`ApplicationContext` là interface trung tâm của Spring IoC Container. Nó chịu trách nhiệm tạo, cấu hình và quản lý các Bean.", difficulty: 'Trung bình' },
    { question: "Spring Boot là gì?", answer: "Spring Boot là một dự án con của Spring, giúp xây dựng ứng dụng Spring độc lập (stand-alone) một cách nhanh chóng với các cấu hình mặc định (convention over configuration).", difficulty: 'Dễ' },
    { question: "Lợi ích của việc sử dụng Spring Boot?", answer: "Tự động cấu hình (Auto-configuration), quản lý phụ thuộc (starter-poms), tích hợp sẵn server (Tomcat), sẵn sàng cho production (actuator).", difficulty: 'Trung bình' },
    { question: "Spring MVC là gì?", answer: "Spring MVC là một framework để xây dựng ứng dụng web theo mô hình Model-View-Controller, tích hợp sẵn trong Spring.", difficulty: 'Dễ' },
    { question: "DispatcherServlet trong Spring MVC hoạt động như thế nào?", answer: "`DispatcherServlet` là Front Controller. Nó nhận tất cả request, chuyển đến `HandlerMapping` (tìm Controller), `HandlerAdapter` (gọi method), nhận `ModelAndView`, và trả về View (qua `ViewResolver`).", difficulty: 'Khó' },
    { question: "Controller trong Spring MVC là gì?", answer: "Là lớp (đánh dấu `@Controller` hoặc `@RestController`) chứa các method (đánh dấu `@RequestMapping`, `@GetMapping`...) xử lý các request HTTP cụ thể.", difficulty: 'Dễ' },
    { question: "Annotation @RestController trong Spring Boot là gì?", answer: "`@RestController` là kết hợp của `@Controller` và `@ResponseBody`. Nó báo cho Spring biết Controller này sẽ trả về dữ liệu (JSON/XML) trực tiếp thay vì tên View.", difficulty: 'Trung bình' },
    { question: "Spring Security là gì?", answer: "Là một framework cung cấp các giải pháp bảo mật (Xác thực - Authentication và Phân quyền - Authorization) cho ứng dụng Spring.", difficulty: 'Trung bình' },
    { question: "OAuth2 là gì?", answer: "Là một giao thức ủy quyền (Authorization Protocol), cho phép ứng dụng bên thứ ba truy cập tài nguyên của người dùng trên hệ thống khác (VD: 'Đăng nhập bằng Google') mà không cần biết mật khẩu.", difficulty: 'Khó' },
    { question: "JWT (JSON Web Token) là gì?", answer: "JWT là một chuẩn (RFC 7519) để tạo ra các token (chuỗi JSON được mã hóa) an toàn. Dùng để xác thực (authentication) API, token chứa thông tin user (claims) và có chữ ký số.", difficulty: 'Khó' },
    { question: "Spring Data JPA là gì?", answer: "Là một phần của Spring Data, giúp đơn giản hóa việc tạo lớp Data Access Layer (DAO/Repository) bằng JPA. Chỉ cần định nghĩa interface, Spring tự tạo triển khai.", difficulty: 'Trung bình' },
    { question: "Spring Batch là gì?", answer: "Là một framework để xử lý các tác vụ hàng loạt (batch processing) - (VD: đọc file lớn, xử lý, ghi DB). Cung cấp quản lý transaction, restart, skip lỗi.", difficulty: 'Khó' },
    { question: "Microservices là gì?", answer: "Là kiến trúc phần mềm phân chia ứng dụng thành các dịch vụ nhỏ, độc lập, chạy quy trình riêng, giao tiếp qua API (thường là HTTP REST).", difficulty: 'Trung bình' },
    { question: "Lợi ích của việc sử dụng Microservices?", answer: "Triển khai độc lập, mở rộng linh hoạt (chỉ scale dịch vụ cần), dễ bảo trì, có thể dùng công nghệ khác nhau cho dịch vụ khác nhau.", difficulty: 'Trung bình' },
    { question: "RESTful Web Service là gì?", answer: "Là dịch vụ web tuân theo kiến trúc REST. Sử dụng các phương thức HTTP (GET, POST, PUT, DELETE) trên các tài nguyên (Resources) (VD: `/users`, `/users/1`).", difficulty: 'Dễ' },
    { question: "Những phương thức HTTP phổ biến trong RESTful Web Service?", answer: "GET (Lấy), POST (Tạo mới), PUT (Cập nhật toàn bộ), DELETE (Xóa), PATCH (Cập nhật một phần).", difficulty: 'Dễ' },
    { question: "JSON và XML khác nhau như thế nào?", answer: "JSON (JavaScript Object Notation) nhẹ hơn, cú pháp đơn giản, dễ đọc (key-value), được ưa chuộng cho REST API. XML (eXtensible Markup Language) chi tiết hơn (dùng thẻ), hỗ trợ namespace, schema.", difficulty: 'Dễ' },
    { question: "WebSocket là gì?", answer: "Là giao thức cung cấp kênh liên lạc hai chiều (full-duplex), thời gian thực giữa client và server qua một kết nối TCP duy nhất (VD: Chat, game online, live data).", difficulty: 'Trung bình' },
    { question: "Spring WebFlux là gì?", answer: "Là framework lập trình web không đồng bộ (asynchronous) và phản ứng (reactive) của Spring (thay thế cho Spring MVC truyền thống). Dùng cho hệ thống cần khả năng chịu tải cao.", difficulty: 'Khó' },
    { question: "Reactive Programming là gì?", answer: "Là mô hình lập trình xử lý các luồng dữ liệu (data streams) không đồng bộ và các sự kiện, với khả năng xử lý áp lực ngược (backpressure).", difficulty: 'Khó' },
    { question: "Actuator trong Spring Boot là gì?", answer: "Cung cấp các endpoint (VD: `/health`, `/metrics`, `/info`) để giám sát (monitoring) và quản lý ứng dụng Spring Boot khi đang chạy.", difficulty: 'Trung bình' },
    { question: "Spring Cloud là gì?", answer: "Là một tập hợp các công cụ để xây dựng các ứng dụng phân tán và microservices (VD: service discovery, configuration, circuit breakers).", difficulty: 'Trung bình' },
    { question: "Eureka trong Spring Cloud là gì?", answer: "(Từ Netflix) Là một dịch vụ đăng ký và phát hiện (Service Discovery & Registry). Microservice tự đăng ký với Eureka và tìm các service khác qua Eureka.", difficulty: 'Khó' },
    { question: "Zuul trong Spring Cloud là gì?", answer: "(Từ Netflix) Là một API Gateway. Nó là cửa ngõ (front door) cho tất cả request, cung cấp routing (định tuyến), filtering (lọc), và load balancing.", difficulty: 'Khó' },
    { question: "Ribbon trong Spring Cloud là gì?", answer: "(Từ Netflix) Là một thư viện cân bằng tải phía client (Client-side Load Balancer). Nó giúp client (VD: service A) chọn 1 trong nhiều instance của service B để gọi.", difficulty: 'Khó' },
    { question: "Hystrix trong Spring Cloud là gì?", answer: "(Từ Netflix) Là thư viện triển khai mẫu Circuit Breaker (ngắt mạch). Ngăn chặn lỗi dây chuyền (cascading failures) khi một service bị sập.", difficulty: 'Khó' },
    { question: "Config Server trong Spring Cloud là gì?", answer: "Là dịch vụ cung cấp cấu hình tập trung (externalized configuration) cho các microservices, thường lấy cấu hình từ Git.", difficulty: 'Khó' },
    { question: "Consul trong Spring Cloud là gì?", answer: "(Từ HashiCorp) Là giải pháp 'tất cả trong một' cho Service Discovery, Health Checking, và Distributed Key-Value Store (thay thế Eureka + Config Server).", difficulty: 'Khó' },
    { question: "Docker là gì?", answer: "Là nền tảng để 'container hóa' ứng dụng. Đóng gói ứng dụng và phụ thuộc của nó vào một 'container' nhẹ, chạy độc lập, nhất quán trên mọi môi trường.", difficulty: 'Dễ' },
    { question: "Kubernetes là gì?", answer: "Là nền tảng điều phối (orchestration) container. Tự động triển khai, mở rộng (scaling), và quản lý các ứng dụng container (như Docker) trên một cụm máy chủ.", difficulty: 'Khó' },
    { question: "Tác dụng của Dockerfile là gì?", answer: "Dockerfile là một file văn bản chứa các hướng dẫn (lệnh) để Docker tự động xây dựng một image (ảnh) cho container.", difficulty: 'Trung bình' },
    { question: "Sự khác biệt giữa Docker và Virtual Machine (VM)?", answer: "<ul><li><strong>VM:</strong> Ảo hóa Phần cứng. Chạy HĐH khách (Guest OS). Nặng, khởi động chậm.</li><li><strong>Docker:</strong> Ảo hóa Hệ điều hành. Chạy chung nhân (kernel) của HĐH chủ (Host OS). Nhẹ, khởi động nhanh.</li></ul>", difficulty: 'Trung bình' },
    { question: "Continuous Integration (CI) là gì?", answer: "CI (Tích hợp liên tục) là quy trình tự động build và test code mỗi khi lập trình viên commit code lên repository. Giúp phát hiện lỗi sớm.", difficulty: 'Trung bình' },
    { question: "Continuous Deployment (CD) là gì?", answer: "CD (Triển khai liên tục) là bước tiếp theo của CI. Tự động triển khai code đã qua kiểm thử (CI) lên môi trường production.", difficulty: 'Trung bình' },
    { question: "Jenkins là gì?", answer: "Jenkins là một công cụ máy chủ tự động hóa (automation server) mã nguồn mở, dùng để thiết lập các quy trình CI/CD.", difficulty: 'Dễ' },
    { question: "Pipeline trong Jenkins là gì?", answer: "Pipeline là một tập hợp các bước (stages) để thực hiện CI/CD (VD: Build -> Test -> Deploy), thường được định nghĩa trong file `Jenkinsfile`.", difficulty: 'Trung bình' },
    { question: "Các bước chính trong một CI/CD pipeline?", answer: "Thường là: Kiểm tra mã nguồn (Checkout) -> Xây dựng (Build) -> Kiểm thử (Test) -> Đóng gói (Package) -> Triển khai (Deploy).", difficulty: 'Trung bình' },

    // Database Nâng Cao (MySQL)
    { question: "Các loại khóa (key) trong cơ sở dữ liệu MySQL là gì?", answer: "<ul><li><strong>Primary Key (Khóa chính):</strong> Định danh duy nhất, không null.</li><li><strong>Foreign Key (Khóa ngoại):</strong> Liên kết đến khóa chính của bảng khác.</li><li><strong>Unique Key (Khóa duy nhất):</strong> Đảm bảo giá trị là duy nhất, cho phép null.</li><li><strong>Composite Key (Khóa phức hợp):</strong> Khóa chính/duy nhất được tạo từ nhiều cột.</li></ul>", difficulty: 'Dễ' },
    { question: "Phân biệt giữa khóa chính (Primary Key) và khóa ngoại (Foreign Key)?", answer: "Primary Key định danh duy nhất mỗi bản ghi trong *chính bảng đó*. Foreign Key thiết lập mối quan hệ, nó là một cột trong bảng này tham chiếu đến Primary Key của bảng khác.", difficulty: 'Dễ' },
    { question: "Normalization (Chuẩn hóa) là gì?", answer: "Là quá trình tổ chức dữ liệu trong CSDL để giảm thiểu dư thừa (redundancy) và phụ thuộc dữ liệu (dependency), cải thiện tính toàn vẹn.", difficulty: 'Trung bình' },
    { question: "Các dạng chuẩn hóa dữ liệu (Normalization Forms) là gì?", answer: "Phổ biến nhất là: 1NF (Dữ liệu nguyên tử), 2NF (Phụ thuộc hoàn toàn vào khóa chính), 3NF (Không có phụ thuộc bắc cầu).", difficulty: 'Trung bình' },
    { question: "Denormalization (Phi chuẩn hóa) là gì?", answer: "Là quá trình cố ý thêm dữ liệu dư thừa vào CSDL đã chuẩn hóa để cải thiện hiệu suất truy vấn (tăng tốc độ đọc, giảm JOIN).", difficulty: 'Trung bình' },
    { question: "View trong MySQL là gì?", answer: "View là một bảng ảo (virtual table) được tạo từ kết quả của một câu lệnh `SELECT`. Nó không lưu dữ liệu thực tế, giúp đơn giản hóa truy vấn và bảo mật.", difficulty: 'Trung bình' },
    { question: "Stored Procedure là gì?", answer: "Stored Procedure là một tập hợp các câu lệnh SQL được đặt tên và lưu trữ trong CSDL, có thể nhận tham số và thực thi theo yêu cầu.", difficulty: 'Trung bình' },
    { question: "Stored Procedure và Function khác nhau như thế nào?", answer: "<ul><li><strong>Function:</strong> Bắt buộc trả về *một* giá trị. Có thể gọi trong `SELECT`.</li><li><strong>Stored Procedure:</strong> Không bắt buộc trả về giá trị (có thể trả về qua tham số `OUT` hoặc `ResultSet`). Gọi bằng `CALL`.</li></ul>", difficulty: 'Trung bình' },
    { question: "Trigger trong MySQL là gì?", answer: "Trigger là một đoạn mã (Stored Procedure đặc biệt) được tự động thực thi khi một sự kiện (INSERT, UPDATE, DELETE) xảy ra trên một bảng cụ thể.", difficulty: 'Trung bình' },
    { question: "Phân biệt giữa Trigger và Stored Procedure?", answer: "Stored Procedure được gọi thủ công (`CALL`). Trigger được thực thi tự động (ngầm) khi có sự kiện thay đổi dữ liệu (INSERT/UPDATE/DELETE).", difficulty: 'Trung bình' },
    { question: "Index (Chỉ mục) trong MySQL là gì?", answer: "Index là một cấu trúc dữ liệu (thường là B-Tree) giúp tăng tốc độ truy vấn `SELECT` (đặc biệt với `WHERE`, `JOIN`) bằng cách cho phép tìm kiếm nhanh hơn.", difficulty: 'Dễ' },
    { question: "Các loại index trong MySQL là gì?", answer: "B-Tree (phổ biến nhất, cho InnoDB), Hash (cho Memory engine), Full-text (tìm kiếm văn bản), Spatial (dữ liệu địa lý).", difficulty: 'Trung bình' },
    { question: "Composite Index là gì?", answer: "Là một index được tạo trên nhiều cột (VD: `INDEX(col1, col2)`). Rất quan trọng cho truy vấn `WHERE` trên nhiều cột đó.", difficulty: 'Trung bình' },
    { question: "Cơ chế hoạt động của B-Tree Index là gì?", answer: "B-Tree (Cây cân bằng) tổ chức dữ liệu theo dạng cây đã được sắp xếp, giúp tìm kiếm, quét (scan) và sắp xếp (ORDER BY) rất nhanh.", difficulty: 'Khó' },
    { question: "Tại sao cần sử dụng Index trong cơ sở dữ liệu?", answer: "Giúp tăng tốc độ `SELECT` đáng kể. Tuy nhiên, nó làm chậm `INSERT`, `UPDATE`, `DELETE` vì CSDL phải cập nhật cả Index.", difficulty: 'Trung bình' },
    { question: "Explain trong MySQL là gì?", answer: "`EXPLAIN` là câu lệnh đặt trước `SELECT` để xem 'kế hoạch thực thi' (Execution Plan) của MySQL. Giúp chẩn đoán truy vấn có chậm hay không, có dùng Index không.", difficulty: 'Khó' },
    { question: "Query Optimization là gì?", answer: "Là quá trình cải thiện hiệu suất của truy vấn SQL bằng cách điều chỉnh câu lệnh SQL, cấu trúc bảng, hoặc thêm Index.", difficulty: 'Trung bình' },
    { question: "Các phương pháp tối ưu hóa truy vấn trong MySQL là gì?", answer: "Sử dụng Index (quan trọng nhất), tránh `SELECT *`, tối ưu hóa `JOIN`, giảm thiểu subquery, sử dụng `EXPLAIN` để phân tích.", difficulty: 'Trung bình' },
    { question: "Partitioning trong MySQL là gì?", answer: "Partitioning (Phân vùng) là kỹ thuật chia nhỏ một bảng rất lớn thành các phần (partitions) nhỏ hơn, dễ quản lý và truy vấn hiệu quả hơn.", difficulty: 'Khó' },
    { question: "Các loại partitioning trong MySQL là gì?", answer: "Range (theo khoảng giá trị), List (theo danh sách), Hash (theo mã băm), Key (tương tự Hash).", difficulty: 'Khó' },
    { question: "Replication trong MySQL là gì?", answer: "Replication (Nhân bản) là quá trình sao chép dữ liệu tự động từ một server MySQL (Master/Primary) sang một hoặc nhiều server khác (Slaves/Replicas).", difficulty: 'Khó' },
    { question: "Các kiểu replication trong MySQL là gì?", answer: "Asynchronous (Không đồng bộ - mặc định), Semi-synchronous (Bán đồng bộ), Synchronous (Đồng bộ - hiếm dùng).", difficulty: 'Khó' },
    { question: "Cluster trong MySQL là gì?", answer: "MySQL Cluster là một giải pháp CSDL phân tán, high-availability (sẵn sàng cao), cho phép dữ liệu được lưu trữ đồng bộ trên nhiều máy chủ (nodes).", difficulty: 'Khó' },
    { question: "Các thành phần của MySQL Cluster là gì?", answer: "Data Nodes (lưu dữ liệu), Management Nodes (quản lý), SQL Nodes (truy cập).", difficulty: 'Khó' },
    { question: "InnoDB và MyISAM khác nhau như thế nào?", answer: "<ul><li><strong>InnoDB:</strong> Mặc định. Hỗ trợ Transaction (ACID), khóa ngoại (Foreign Key), và khóa dòng (Row-level locking).</li><li><strong>MyISAM:</strong> Cũ. Không hỗ trợ Transaction, khóa bảng (Table-level locking) -> nhanh khi đọc nhưng chậm khi ghi đồng thời.</li></ul>", difficulty: 'Trung bình' },
    { question: "ACID trong cơ sở dữ liệu là gì?", answer: "ACID là 4 tính chất đảm bảo toàn vẹn giao dịch: <ul><li><strong>A</strong>tomicity (Nguyên tử)</li><li><strong>C</strong>onsistency (Nhất quán)</li><li><strong>I</strong>solation (Cô lập)</li><li><strong>D</strong>urability (Bền vững)</li></ul>", difficulty: 'Khó' },
    { question: "Transaction trong MySQL là gì?", answer: "Transaction là một tập hợp các câu lệnh SQL (VD: chuyển tiền = 1 TRỪ + 1 CỘNG) được thực thi như một đơn vị: hoặc thành công tất cả, hoặc thất bại tất cả (rollback).", difficulty: 'Trung bình' },
    { question: "Isolation Levels trong MySQL là gì?", answer: "Là mức độ cô lập giữa các transaction chạy đồng thời: Read Uncommitted, Read Committed, Repeatable Read (mặc định của InnoDB), Serializable.", difficulty: 'Khó' },
    { question: "Deadlock trong cơ sở dữ liệu là gì?", answer: "Deadlock (Kẹt khóa) xảy ra khi hai (hoặc nhiều) transaction giữ khóa và chờ khóa của nhau, tạo thành vòng lặp chờ vô tận.", difficulty: 'Khó' },
    { question: "Làm thế nào để tránh deadlock trong MySQL?", answer: "Khóa tài nguyên theo thứ tự cố định, giữ transaction ngắn gọn, sử dụng Isolation Level thấp hơn (nếu có thể), xử lý lỗi deadlock (retry).", difficulty: 'Khó' },
    { question: "Lazy Initialization (Lazy Loading) trong Hibernate là gì?", answer: "Là kỹ thuật chỉ tải dữ liệu liên quan (VD: danh sách `comments` của `Post`) khi thực sự cần (gọi `post.getComments()`) thay vì tải ngay từ đầu.", difficulty: 'Khó' },
    { question: "Hibernate Cache là gì?", answer: "Là cơ chế lưu trữ tạm thời dữ liệu để giảm tải truy vấn CSDL.", difficulty: 'Khó' },
    { question: "Các loại cache trong Hibernate là gì?", answer: "First Level Cache (Session Cache), Second Level Cache (SessionFactory Cache), Query Cache.", difficulty: 'Khó' },
    { question: "JpaRepository trong Spring Data JPA là gì?", answer: "Là một interface cung cấp sẵn các phương thức CRUD cơ bản (save, findById, findAll, delete) và các phương thức truy vấn mở rộng cho entity.", difficulty: 'Trung bình' },
    { question: "@Entity annotation trong JPA là gì?", answer: "`@Entity` đánh dấu một lớp Java là một thực thể JPA.", difficulty: 'Dễ' },
    { question: "@Table annotation trong JPA là gì?", answer: "`@Table` xác định tên bảng mà thực thể JPA ánh xạ đến.", difficulty: 'Dễ' },
    { question: "@Id annotation trong JPA là gì?", answer: "`@Id` xác định thuộc tính là khóa chính của thực thể JPA.", difficulty: 'Dễ' },
    { question: "@GeneratedValue annotation trong JPA là gì?", answer: "`@GeneratedValue` xác định chiến lược tạo giá trị tự động cho khóa chính.", difficulty: 'Trung bình' },
    { question: "@OneToOne annotation trong JPA là gì?", answer: "`@OneToOne` xác định mối quan hệ một-một giữa hai thực thể.", difficulty: 'Trung bình' },
    { question: "@OneToMany annotation trong JPA là gì?", answer: "`@OneToMany` xác định mối quan hệ một-nhiều giữa hai thực thể.", difficulty: 'Trung bình' },
    { question: "@ManyToOne annotation trong JPA là gì?", answer: "`@ManyToOne` xác định mối quan hệ nhiều-một giữa hai thực thể.", difficulty: 'Trung bình' },
    { question: "@ManyToMany annotation trong JPA là gì?", answer: "`@ManyToMany` xác định mối quan hệ nhiều-nhiều giữa hai thực thể.", difficulty: 'Trung bình' },
    { question: "NamedQuery trong JPA là gì?", answer: "NamedQuery là một truy vấn định danh được khai báo trong thực thể JPA và có thể tái sử dụng.", difficulty: 'Trung bình' },
    { question: "@Query annotation trong Spring Data JPA là gì?", answer: "`@Query` được sử dụng để định nghĩa truy vấn HQL hoặc SQL trực tiếp trong repository.", difficulty: 'Trung bình' },
    { question: "Pagination trong Spring Data JPA hoạt động như thế nào?", answer: "Sử dụng `Pageable` và `Page<T>` để giới hạn và phân trang kết quả truy vấn.", difficulty: 'Trung bình' },
    { question: "Làm thế nào để xử lý ngoại lệ trong Spring Data JPA?", answer: "Sử dụng `@ExceptionHandler` hoặc `@ControllerAdvice` để xử lý ngoại lệ.", difficulty: 'Trung bình' },
    { question: "Spring Transaction Management là gì?", answer: "Spring Transaction Management cung cấp các giải pháp quản lý transaction cho ứng dụng Spring, hỗ trợ cả transaction lập trình và khai báo.", difficulty: 'Trung bình' },
    { question: "@Transactional annotation trong Spring là gì?", answer: "`@Transactional` được sử dụng để đánh dấu một phương thức hoặc lớp tham gia vào một transaction.", difficulty: 'Trung bình' },
    { question: "Propagation trong Spring Transaction Management là gì?", answer: "Propagation xác định cách thức transaction hiện tại được xử lý khi phương thức được gọi trong một transaction khác.", difficulty: 'Khó' },
    { question: "Isolation trong Spring Transaction Management là gì?", answer: "Isolation xác định mức độ tách biệt giữa các transaction đang chạy đồng thời.", difficulty: 'Khó' },
    { question: "Timeout trong Spring Transaction Management là gì?", answer: "Timeout xác định thời gian tối đa một transaction có thể chạy trước khi bị hủy bỏ.", difficulty: 'Trung bình' },
    { question: "Rollback trong Spring Transaction Management là gì?", answer: "Rollback là quá trình hoàn tác các thay đổi trong một transaction nếu có lỗi xảy ra.", difficulty: 'Trung bình' },
];

const categoryMap: Record<string, string> = {
    "Java là gì?": "Java Căn Bản",
    "Lập trình hướng đối tượng (OOP) là gì?": "Lập Trình Hướng Đối Tượng (OOP)",
    "JDBC là gì?": "Database Căn Bản (JDBC, JPA)",
    "Java IO là gì?": "Java IO & String",
    "Java Swing là gì?": "Java Swing",
    "Lambda expression trong Java có những lợi ích gì?": "Java Nâng Cao (Multithread, JVM...)",
    "Servlet là gì?": "Lập Trình Web (Servlet, Spring)",
    "Các loại khóa (key) trong cơ sở dữ liệu MySQL là gì?": "Database Nâng Cao (MySQL)"
};

let currentCategory = '';
const processedQuestions = rawQuestions.map((q, index) => {
    if (categoryMap[q.question]) {
        currentCategory = categoryMap[q.question];
    }
    return {
        ...q,
        id: index + 1,
        status: 'Chưa học' as const,
        category: currentCategory
    };
});

const groupedByCategory = processedQuestions.reduce((acc, q) => {
    if (!acc[q.category]) {
        acc[q.category] = [];
    }
    acc[q.category].push(q);
    return acc;
}, {} as Record<string, (typeof processedQuestions[0])[]>);

export const JAVA_INTERVIEW_QUESTIONS: QuestionCategory[] = Object.keys(groupedByCategory).map(categoryTitle => ({
    title: categoryTitle,
    questions: groupedByCategory[categoryTitle]
}));

export const ALL_QUESTIONS = processedQuestions;

export const CATEGORIES = JAVA_INTERVIEW_QUESTIONS.map(cat => cat.title);
export const DIFFICULTIES: QuestionDifficulty[] = ['Dễ', 'Trung bình', 'Khó'];
